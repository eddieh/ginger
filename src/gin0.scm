#!/usr/bin/env gsi
; This file contains code generated by the Ginger compiler.  Do not edit.
(include "support.scm")

(letrec
 ((ascii-a #\a)
  (ascii-b #\b)
  (ascii-c #\c)
  (ascii-d #\d)
  (ascii-e #\e)
  (ascii-f #\f)
  (ascii-g #\g)
  (ascii-h #\h)
  (ascii-i #\i)
  (ascii-j #\j)
  (ascii-k #\k)
  (ascii-l #\l)
  (ascii-m #\m)
  (ascii-n #\n)
  (ascii-o #\o)
  (ascii-p #\p)
  (ascii-q #\q)
  (ascii-r #\r)
  (ascii-s #\s)
  (ascii-t #\t)
  (ascii-u #\u)
  (ascii-v #\v)
  (ascii-w #\w)
  (ascii-x #\x)
  (ascii-y #\y)
  (ascii-z #\z)
  (ascii-A #\A)
  (ascii-B #\B)
  (ascii-C #\C)
  (ascii-D #\D)
  (ascii-E #\E)
  (ascii-F #\F)
  (ascii-G #\G)
  (ascii-H #\H)
  (ascii-I #\I)
  (ascii-J #\J)
  (ascii-K #\K)
  (ascii-L #\L)
  (ascii-M #\M)
  (ascii-N #\N)
  (ascii-O #\O)
  (ascii-P #\P)
  (ascii-Q #\Q)
  (ascii-R #\R)
  (ascii-S #\S)
  (ascii-T #\T)
  (ascii-U #\U)
  (ascii-V #\V)
  (ascii-W #\W)
  (ascii-X #\X)
  (ascii-Y #\Y)
  (ascii-Z #\Z)
  (ascii-0 #\0)
  (ascii-1 #\1)
  (ascii-2 #\2)
  (ascii-3 #\3)
  (ascii-4 #\4)
  (ascii-5 #\5)
  (ascii-6 #\6)
  (ascii-7 #\7)
  (ascii-8 #\8)
  (ascii-9 #\9)
  (ascii-newline #\newline)
  (ascii-tab #\tab)
  (ascii-space #\space)
  (ascii-period #\.)
  (ascii-slash #\/)
  (ascii-backslash #\\)
  (ascii-left-parenthesis #\()
  (ascii-right-parenthesis #\))
  (ascii-underscore #\_)
  (ascii-plus #\+)
  (ascii-minus #\-)
  (ascii-mult #\*)
  (ascii-dollar #\$)
  (ascii-at #\@)
  (ascii-percent #\%)
  (ascii-exclamation #\!)
  (ascii-less-than #\<)
  (ascii-greater-than #\>)
  (ascii-question #\?)
  (ascii-colon #\:)
  (ascii-semi-colon #\;)
  (ascii-single-quote #\')
  (ascii-double-quote #\")
  (ascii-equals #\=)
  (ascii-pound #\#)
  (ascii-return #\return)
  (ascii-nul #\nul)
  (ascii-cr #\return)
  (ascii-lf #\newline)
  (banner #f)
  (output #f)
  (output-file-name #f)
  (input-file-name #f)
  (last-char #f)
  (line #f)
  (column #f)
  (cbq-indent #f)
  (tag (lambda (a b)
   (begin 
    (cons a b))))
  (type (lambda (v)
   (begin 
    (car v))))
  (form (lambda (v)
   (begin 
    (cdr v))))
  (relate (lambda (a b)
   (begin 
    (noop))))
  (get-char (lambda (input)
   (begin 
    
    
        (cond ((not last-char) 
    (begin 
     (read-char input))) (else 
    (begin 
          (cond ((char? last-char) 
     (letrec
      ((current-char #f)) 
      (begin 
       (set! current-char last-char)
       (set! last-char #f)
       current-char))) (else 
     (letrec
      ((current-char #f)) 
      (begin 
       (set! current-char (string-first last-char))
              (cond ((= (string-length last-char) 2) 
       (begin 
        (set! last-char (string-first (string-rest last-char))))) (else 
       (begin 
        (set! last-char (string-rest last-char))))) 
       current-char)))) ))) )))
  (unget-char (lambda (input c)
   (begin 
    
        (cond ((not last-char) 
    (begin 
     (set! last-char c))) (else 
    (begin 
     (set! last-char (new-string c last-char))))) )))
  (indentation #f)
  (indent (lambda (amount)
   (begin 
    
    
        (cond ((<= amount 0) "") (else (string-append " " (indent (- amount 1))))) )))
  (eos? (lambda (input)
   (begin 
    (eof-object? (peek-char input)))))
  (char->base-number (lambda (v b)
   (letrec
    ((c #f)) 
    (begin 
     
     
     
     (set! c 
     (begin 
            (cond ((< b 2) 
      (begin 
       #f)) ((> b 36) 
      (begin 
       #f))((>= (char->integer v) (char->integer ascii-a)) 
      (begin 
       (+ (- (char->integer v) (char->integer ascii-a)) 10)))((>= (char->integer v) (char->integer ascii-A)) 
      (begin 
       (+ (- (char->integer v) (char->integer ascii-A)) 10)))((>= (char->integer v) (char->integer ascii-0)) 
      (begin 
       (- (char->integer v) (char->integer ascii-0))))(else #f)) ))
          (cond ((not c) #f) ((< c b) c)(else #f)) ))))
  (char-base-numeric? (lambda (v b)
   (begin 
    
    
        (cond ((not (char->base-number v b)) #f) (else #t)) )))
  (char-eol? (lambda (c)
   (begin 
    
        (cond ((char=? c ascii-lf) #t) ((char=? c ascii-cr) #t)(else #f)) )))
  (char->double-quote-escape (lambda (c)
   (begin 
    
        (cond ((char=? c ascii-newline) "\\n") ((char=? c ascii-return) "\\r")(else c)) )))
  (new-string (lambda (a b)
   (begin 
        (cond ((and (string? a) (string? b)) (string-append a b)) ((and (string? a) (char? b)) (string-append a (string b)))((and (char? a) (string? b)) (string-append (string a) b))((and (char? a) (char? b)) (string-append (string a) (string b)))(else #f)) )))
  (string-first (lambda (v)
   (begin 
    
        (cond ((= (string-length v) 0) #f) (else (car (string->list (substring v 0 1))))) )))
  (string-last (lambda (v)
   (begin 
    
        (cond ((= (string-length v) 0) #f) (else (car (string->list (substring v (- (string-length v) 1) (string-length v)))))) )))
  (string-rest (lambda (v)
   (begin 
    
        (cond ((<= (string-length v) 1) #f) (else (substring v 1 (string-length v)))) )))
  (noop (lambda ()
   (begin 
    #t)))
  (string-boolean? (lambda (v)
   (begin 
    
        (cond ((or (string=? v "true") (string=? v "false")) #t) (else #f)) )))
  (string->boolean (lambda (v)
   (begin 
    
        (cond ((or (string=? v "true") (string=? v "false")) 
    (begin 
          (cond ((string=? v "true") #t) (else #f)) )) (else #f)) )))
  (string-ellipses? (lambda (v)
   (begin 
    
        (cond ((string=? v "..") #t) (else #f)) )))
  (string-numeric? (lambda (v)
   (begin 
    
        (cond ((= (string-length v) 0) #f) ((and (= (string-length v) 1) (char-numeric? (string-first v))) #t)((char-numeric? (string-first v)) (string-numeric? (string-rest v)))(else #f)) )))
  (string->base-number (lambda (v b)
   (letrec
    ((string->base-number-i (lambda (v b i)
      (begin 
       
       
       
              (cond ((= (string-length v) 0) #f) ((and (= (string-length v) 1) (char-base-numeric? (string-first v) b)) 
       (begin 
        (char->base-number (string-first v) b)))((char-base-numeric? (string-first v) b) 
       (letrec
        ((n #f)) 
        (begin 
         (set! n (string->base-number-i (string-rest v) b (- i 1)))
                  (cond ((not n) #f) (else (+ (* (char->base-number (string-first v) b) (expt b (- i 1))) n))) )))(else #f)) )))) 
    (begin 
     
     
     (string->base-number-i v b (string-length v))))))
  (string-base-numeric? (lambda (v b)
   (begin 
    
    
        (cond ((not (string->base-number v b)) #f) (else #t)) )))
  (string->intent-integer (lambda (v)
   (letrec
    ((v0 #f)
     (v1 #f)
     (v2 #f)) 
    (begin 
     
     (set! v0 (string-split v ascii-underscore))
     (set! v1 (car v0))
     (set! v2 (cdr v0))
          (cond ((string=? v1 "") #f) ((and (null? v2) (string-numeric? v1)) (string->number v1))((null? v2) #f)((and (null? (cdr v2)) (string-numeric? (car v2)) (string-base-numeric? v1 (string->number (car v2)))) 
     (begin 
      (string->base-number v1 (string->number (car v2)))))(else #f)) ))))
  (string-intent-integer? (lambda (v)
   (begin 
    
        (cond ((not (string->intent-integer v)) #f) (else #t)) )))
  (string->intent-ratio (lambda (v)
   (letrec
    ((v0 #f)
     (v1 #f)
     (v2 #f)) 
    (begin 
     
     (set! v0 (string-split v ascii-slash))
     (set! v1 (car v0))
     (set! v2 (cdr v0))
          (cond ((string=? v1 "") #f) ((and (null? v2) (string-intent-integer? v1)) (string->intent-integer v1))((null? v2) #f)((and (null? (cdr v2)) (string-intent-integer? (car v2)) (string-intent-integer? v1)) 
     (begin 
      (/ (string->intent-integer v1) (string->intent-integer (car v2)))))(else #f)) ))))
  (string-intent-ratio? (lambda (v)
   (begin 
    
        (cond ((not (string->intent-ratio v)) #f) (else #t)) )))
  (string->intent-scientific (lambda (v)
   (letrec
    ((va #f)
     (n1 #f)
     (n2 #f)
     (exponent #f)
     (base #f)) 
    (begin 
     
     (set! va #f)
     (set! n1 "0")
     (set! n2 "0")
     (set! exponent "0")
     (set! base "10")
     (set! va (string-split v ascii-e))
          (cond ((not (null? (cdr va))) 
     (begin 
            (cond ((not (null? (cdr (cdr va)))) 
      (begin 
       (set! exponent #f))) (else 
      (begin 
       (set! exponent (car (cdr va)))))) )) ) 
     (set! va (string-split (car va) ascii-underscore))
          (cond ((not (null? (cdr va))) 
     (begin 
            (cond ((not (null? (cdr (cdr va)))) 
      (begin 
       (set! base #f))) (else 
      (begin 
       (set! base (car (cdr va)))))) )) ) 
     (set! va (string-split (car va) ascii-period))
          (cond ((not (null? (cdr va))) 
     (begin 
            (cond ((not (null? (cdr (cdr va)))) 
      (begin 
       (set! n2 #f))) (else 
      (begin 
       (set! n2 (car (cdr va)))))) )) ) 
     (set! n1 (car va))
          (cond ((and (not (not n1)) (not (not n2)) (not (not base)) (not (not exponent)) (string-numeric? exponent) (string-numeric? base) (string-base-numeric? n1 (string->number base)) (string-base-numeric? n2 (string->number base))) 
     (begin 
      (+ (* (string->base-number n1 (string->number base)) (expt (string->number base) (string->number exponent))) (/ (string->base-number n2 (string->number base)) (expt (string->number base) (- (string-length n2) (string->number exponent))))))) (else 
     (begin 
      #f))) ))))
  (string-intent-scientific? (lambda (v)
   (begin 
    
        (cond ((not (string->intent-ratio v)) #f) (else #t)) )))
  (string-intent-rational? (lambda (v)
   (begin 
    
        (cond ((string-intent-ratio? v) #t) ((string-intent-scientific? v) #t)(else #f)) )))
  (string->intent-rational (lambda (v)
   (begin 
    
        (cond ((string-intent-ratio? v) (string->intent-ratio v)) ((string-intent-scientific? v) (string->intent-scientific v))(else #f)) )))
  (string->intent-complex (lambda (v)
   (letrec
    ((va #f)) 
    (begin 
     
     (set! va (string-split v ascii-plus))
          (cond ((null? (cdr va)) #f) (else 
     (letrec
      ((real-part #f)
       (vb #f)) 
      (begin 
       (set! real-part (car va))
       (set! vb (string-split (cadr va) ascii-i))
              (cond ((null? (cdr vb)) #f) (else 
       (letrec
        ((imaginary-part #f)
         (rp #f)
         (ip #f)) 
        (begin 
         (set! imaginary-part (car vb))
         (set! rp 
         (begin 
                    (cond ((string-intent-integer? real-part) (string->intent-integer real-part)) ((string-intent-ratio? real-part) (string->intent-ratio real-part))((string-intent-scientific? real-part) (string->intent-scientific real-part))) ))
         (set! ip 
         (begin 
                    (cond ((string-intent-integer? imaginary-part) (string->intent-integer imaginary-part)) ((string-intent-ratio? imaginary-part) (string->intent-ratio imaginary-part))((string-intent-scientific? imaginary-part) (string->intent-scientific imaginary-part))) ))
                  (cond ((or (not rp) (not ip)) #f) (else (+ rp (* ip 1)))) )))) )))) ))))
  (string-intent-complex? (lambda (v)
   (begin 
    
        (cond ((not (string->intent-complex v)) #f) (else #t)) )))
  (string->intent-symbol (lambda (v)
   (letrec
    ((char-legal-symbol? (lambda (v)
      (begin 
              (cond ((char-alphabetic? v) #t) ((char-numeric? v) #t)((char=? v ascii-plus) #t)((char=? v ascii-minus) #t)((char=? v ascii-mult) #t)((char=? v ascii-slash) #t)((char=? v ascii-percent) #t)((char=? v ascii-dollar) #t)((char=? v ascii-at) #t)((char=? v ascii-exclamation) #t)((char=? v ascii-less-than) #t)((char=? v ascii-greater-than) #t)((char=? v ascii-equals) #t)((char=? v ascii-question) #t)(else #f)) )))
     (string-legal-symbol? (lambda (v)
      (begin 
              (cond ((= (string-length v) 0) #f) ((and (= (string-length v) 1) (char-legal-symbol? (string-first v))) #t)((char-legal-symbol? (string-first v)) (string-legal-symbol? (string-rest v)))(else #f)) )))) 
    (begin 
     
          (cond ((not (not (string-intent-complex? v))) #f) (else 
     (begin 
            (cond ((string-legal-symbol? v) v) (else #f)) ))) ))))
  (string-intent-symbol? (lambda (v)
   (begin 
    
        (cond ((not (string->intent-symbol v)) #f) (else #t)) )))
  (string->label (lambda (v)
   (begin 
        (cond ((< (string-length v) 2) #f) (else 
    (letrec
     ((c #f)) 
     (begin 
      (set! c (string-intent-symbol? (substring v 0 (- (string-length v) 1))))
            (cond ((and c (char=? (string-last v) ascii-colon)) v) (else #f)) )))) )))
  (string-label? (lambda (v)
   (begin 
    
        (cond ((not (string->label v)) #f) (else #t)) )))
  (string-colon-command? (lambda (v)
   (begin 
    
        (cond ((and (eq? (string-first v) ascii-colon) (or (string-intent-symbol? (string-rest v)) (= (string-length v) 1))) #t) (else #f)) )))
  (<binding>-new (lambda (name export-name term type expansion-function)
   (begin 
    (vector name export-name term type expansion-function))))
  (<binding>-get-name (lambda (obj)
   (begin 
    (vector-ref obj 0))))
  (<binding>-get-export-name (lambda (obj)
   (begin 
    (vector-ref obj 1))))
  (<binding>-get-term (lambda (obj)
   (begin 
    (vector-ref obj 2))))
  (<binding>-get-type (lambda (obj)
   (begin 
    (vector-ref obj 3))))
  (<binding>-get-expansion-function (lambda (obj)
   (begin 
    (vector-ref obj 4))))
  (<binding>-set-name (lambda (obj v)
   (begin 
    (vector-set! obj 0 v))))
  (<binding>-set-export-name (lambda (obj v)
   (begin 
    (vector-set! obj 1 v))))
  (<binding>-set-term (lambda (obj v)
   (begin 
    (vector-set! obj 2 v))))
  (<binding>-set-type (lambda (obj v)
   (begin 
    (vector-set! obj 3 v))))
  (<binding>-set-expansion-function (lambda (obj v)
   (begin 
    (vector-set! obj 4 v))))
  (<term>-new (lambda (parent children bindings type parse-indent line column value)
   (begin 
    (vector parent children bindings type parse-indent line column value 0))))
  (<term>-get-parent (lambda (obj)
   (begin 
    (vector-ref obj 0))))
  (<term>-get-children (lambda (obj)
   (begin 
    (vector-ref obj 1))))
  (<term>-get-bindings (lambda (obj)
   (begin 
    (vector-ref obj 2))))
  (<term>-get-type (lambda (obj)
   (begin 
    (vector-ref obj 3))))
  (<term>-get-parse-indent (lambda (obj)
   (begin 
    (vector-ref obj 4))))
  (<term>-get-line (lambda (obj)
   (begin 
    (vector-ref obj 5))))
  (<term>-get-column (lambda (obj)
   (begin 
    (vector-ref obj 6))))
  (<term>-get-value (lambda (obj)
   (begin 
    (vector-ref obj 7))))
  (<term>-get-paren-balance (lambda (obj)
   (begin 
    (vector-ref obj 8))))
  (<term>-set-parent (lambda (obj v)
   (begin 
    (vector-set! obj 0 v))))
  (<term>-set-children (lambda (obj v)
   (begin 
    (vector-set! obj 1 v))))
  (<term>-set-bindings (lambda (obj v)
   (begin 
    (vector-set! obj 2 v))))
  (<term>-set-type (lambda (obj v)
   (begin 
    (vector-set! obj 3 v))))
  (<term>-set-parse-indent (lambda (obj v)
   (begin 
    (vector-set! obj 4 v))))
  (<term>-set-line (lambda (obj v)
   (begin 
    (vector-set! obj 5 v))))
  (<term>-set-column (lambda (obj v)
   (begin 
    (vector-set! obj 6 v))))
  (<term>-set-value (lambda (obj v)
   (begin 
    (vector-set! obj 7 v))))
  (<term>-set-paren-balance (lambda (obj v)
   (begin 
    (vector-set! obj 8 v))))
  (begin-group? (lambda (t)
   (letrec
    ((c #f)) 
    (begin 
     (set! c (<term>-get-children t))
          (cond ((null? c) #f) (else 
     (begin 
            (cond ((eq? (<term>-get-type (car c)) 'begin) #t) (else #f)) ))) ))))
  (paren-balanced (lambda ()
   (letrec
    ((paren-balanced2 (lambda (t)
      (begin 
       
              (cond ((begin-group? t) 
       (begin 
                (cond ((= (<term>-get-paren-balance t) 0) (list)) (else t)) )) (else 
       (begin 
        (paren-balanced2 (<term>-get-parent t))))) )))) 
    (begin 
     (paren-balanced2 tree-current)))))
  (paren-add (lambda ()
   (letrec
    ((add-paren2 (lambda (t)
      (begin 
       
              (cond ((begin-group? t) 
       (begin 
        (<term>-set-paren-balance t (+ (<term>-get-paren-balance t) 1)))) (else 
       (begin 
        (add-paren2 (<term>-get-parent t))))) )))) 
    (begin 
     (add-paren2 tree-current)))))
  (paren-remove (lambda ()
   (letrec
    ((remove-paren2 (lambda (t)
      (begin 
       
              (cond ((begin-group? t) 
       (begin 
        (<term>-set-paren-balance t (- (<term>-get-paren-balance t) 1)))) (else 
       (begin 
        (remove-paren2 (<term>-get-parent t))))) )))) 
    (begin 
     (remove-paren2 tree-current)))))
  (print-term (lambda (t)
   (letrec
    ((print-term2 (lambda (t)
      (letrec
       ((it (lambda (i)
         (begin 
                    (cond ((or (null? i) (null? (car i))) 
          (begin 
           #f)) (else 
          (begin 
           (print-term2 (car i))
                      (cond ((not (null? (cdr i))) 
           (begin 
            (println ""))) ) 
           (it (cdr i))))) )))) 
       (begin 
        (print (indent indentation) "(" (<term>-get-type t) " value:'" (<term>-get-value t) "' indent:'" (<term>-get-parse-indent t) "' line:'" (<term>-get-line t) "' ")
                (cond ((not (boolean? (<term>-get-children t))) 
        (begin 
         (println "")
         (++! indentation)
         (it (<term>-get-children t))
         (--! indentation))) ) 
        (print ")")))))) 
    (begin 
     (println "")
     (print-term2 t)
     (println "")
     (println "")))))
  (<group>-new (lambda (line column)
   (begin 
    (<term>-new #f (list) (list) 'group 0 line column #f))))
  (<value>-new (lambda (value-type value line column)
   (begin 
    (<term>-new #f #f #f value-type 0 line column value))))
  (<begin>-new (lambda (line column)
   (begin 
    (<term>-new #f #f #f 'begin 0 line column #f))))
  (<group>-add-child (lambda (t c)
   (begin 
    
    (<term>-set-parent c t)
    (<term>-set-children t (append (<term>-get-children t) (list c))))))
  (tree-head #f)
  (tree-current #f)
  (tree-add (lambda (v)
   (begin 
    (<group>-add-child tree-current v))))
  (tree-push (lambda ()
   (letrec
    ((g0 #f)) 
    (begin 
     (set! g0 (<group>-new line column))
     (tree-add g0)
     (set! tree-current g0)))))
  (tree-pop (lambda ()
   (begin 
    (set! tree-current (<term>-get-parent tree-current)))))
  (tree-unpop (lambda ()
   (begin 
    (set! tree-current (last (<term>-get-children tree-current))))))
  (tree-sibling-count (lambda ()
   (begin 
        (cond ((eq? (<term>-get-parent tree-current) #f) 
    (begin 
     0)) (else 
    (begin 
     (- (length (<term>-get-children (<term>-get-parent tree-current))) 1)))) )))
  (state-stack #f)
  (state-push (lambda (s)
   (begin 
    (set! state-stack (append state-stack (list s))))))
  (state-top (lambda ()
   (begin 
    (last state-stack))))
  (state-pop (lambda ()
   (begin 
    (set! state-stack (ginger-head state-stack)))))
  (mangle (lambda (t)
   (begin 
    t)))
  (split-list (lambda (lst v)
   (letrec
    ((a #f)
     (b #f)
     (middle #f)) 
    (begin 
     (set! a (list))
     (set! b (list))
     (set! middle #f)
          (ginger-for-each l lst 
     (begin 
            (cond ((eq? l v) 
      (begin 
       (set! middle #t))) (else 
      (begin 
              (cond ((eq? middle #f) 
       (begin 
        (set! a (append a (list l))))) (else 
       (begin 
        (set! b (append b (list l)))))) ))) ))
     (cons a b)))))
  (eval (lambda (t)
   (letrec
    ((input #f)
     (old-tree-head #f)
     (scheme-eval-string #f)) 
    (begin 
     (set! input (open-input-string t))
     (set! old-tree-head tree-head)
     (set! state-stack (list))
     (set! tree-head (<group>-new 0 0))
     (set! tree-current tree-head)
     (tree-add (<begin>-new 0 0))
     (set! line 1)
     (set! column 0)
     (parse input)
     (close-input-port input)
     (println "Expand includes..")
     (include-expand tree-head)
     (println "Inserting bindings..")
     (insert-bindings tree-head)
     (println "Inserting immutable calls..")
     (insert-calls tree-head #f)
     (set! output (open-output-string))
     (println "Writing code..")
     (expand tree-head)
     (close-output-port output)
     (set! scheme-eval-string (get-output-string output))
     (eval (read (open-input-string scheme-eval-string)))))))
  (include-filename (lambda (terms)
   (begin 
    (<term>-get-value (second terms)))))
  (open-include-file (lambda (filename)
   (letrec
    ((found-include-file #f)
     (include-file-path #f)) 
    (begin 
     (set! found-include-file #f)
     (set! include-file-path "")
          (cond ((file-exists? filename) 
     (begin 
      (set! found-include-file #t)
      (set! include-file-path filename))) (else 
     (letrec
      ((inc-paths #f)) 
      (begin 
       (set! inc-paths (string-split (getenv "GIN_INCLUDE_PATH" "") ascii-colon))
              (while (and (not found-include-file) (not (null? inc-paths))) 
       (letrec
        ((path #f)) 
        (begin 
         (set! path (string-append (car inc-paths) "/" filename))
                  (cond ((file-exists? path) 
         (begin 
          (set! found-include-file #t)
          (set! include-file-path path))) ) 
         (set! inc-paths (cdr inc-paths))))))))) 
          (cond ((not found-include-file) 
     (begin 
      (println "No file found for include: " filename)
      (exit))) ) 
     (open-input-file include-file-path)))))
  (include-expansion (lambda (v)
   (letrec
    ((parent #f)
     (parent-parent #f)
     (terms #f)
     (input #f)
     (old-tree-head #f)
     (tmp #f)
     (new-stuff #f)) 
    (begin 
     (set! parent (<term>-get-parent v))
     (set! parent-parent (<term>-get-parent parent))
     (set! terms (<term>-get-children parent))
     (set! input (open-include-file (include-filename terms)))
     (set! old-tree-head tree-head)
     (set! state-stack (list))
     (set! tree-head (<group>-new 0 0))
     (set! tree-current tree-head)
     (tree-add (<begin>-new 0 0))
     (set! line 1)
     (set! column 0)
     (parse input)
     (close-input-port input)
     (set! tmp (split-list (<term>-get-children parent-parent) parent))
     (<term>-set-children parent-parent (append (car tmp) (cdr (<term>-get-children tree-head)) (cdr tmp)))
     (set! new-stuff (<term>-get-children tree-head))
     (set! tree-head old-tree-head)
     (expand (car new-stuff))))))
  (def-expansion (lambda (v)
   (letrec
    ((terms #f)
     (first-term #f)) 
    (begin 
     (set! terms (<term>-get-children (<term>-get-parent v)))
     (set! first-term #t)
          (cond ((= (length terms) 4) 
     (begin 
      (print output "(lambda (")
            (ginger-for-each i (<term>-get-children (caddr terms)) 
      (begin 
              (cond (first-term 
       (begin 
        (set! first-term #f))) (else 
       (begin 
        (print output " ")))) 
       (print output (<term>-get-value i))))
      (print output ")")
      (++! indentation)
      (expand (cadddr terms))
      (--! indentation)
      (print output ")"))) ((= (length terms) 3) 
     (begin 
      (print output "(set! " (<term>-get-value (cadr terms)) " ")
      (expand (caddr terms))
      (print output ")")))) ))))
  (doc-expansion (lambda (v)
   (begin 
    #f)))
  (ensure-expansion (lambda (v)
   (begin 
    #f)))
  (require-expansion (lambda (v)
   (begin 
    #f)))
  (class-expansion (lambda (v)
   (begin 
    #f)))
  (second (lambda (v)
   (begin 
    (car (cdr v)))))
  (quote-expansion-raw (lambda (v strict star)
   (letrec
    ((quote-expansion2 (lambda (v strict star)
      (begin 
              (cond ((eq? (<term>-get-type v) 'symbol) 
       (begin 
        (quoted-symbol-expansion v))) ((eq? (<term>-get-type v) 'begin) 
       (begin 
                (cond ((eq? star 'star) 
        (begin 
         (print output " begin "))) (else 
        (begin 
         (noop)))) ))((eq? (<term>-get-type v) 'group) 
       (letrec
        ((children #f)) 
        (begin 
         (set! children (<term>-get-children v))
                  (cond ((and (eq? (<term>-get-type (car children)) 'symbol) (string=? (<term>-get-value (car children)) "unquote") (eq? strict 'not-strict)) 
         (begin 
          (expand (second children)))) (else 
         (begin 
          (print output "(list ")
                    (ginger-for-each i children 
          (begin 
           (quote-expansion2 i strict star)
           (print output " ")))
          (print output ")")))) )))(else 
       (begin 
        (expand v)))) )))
     (terms #f)) 
    (begin 
     (set! terms (<term>-get-children (<term>-get-parent v)))
     (quote-expansion2 (second terms) strict star)))))
  (quote-expansion (lambda (v)
   (begin 
    (quote-expansion-raw v 'not-strict 'not-star))))
  (quote*-expansion (lambda (v)
   (begin 
    (quote-expansion-raw v 'not-strict 'star))))
  (strict-quote-expansion (lambda (v)
   (begin 
    (quote-expansion-raw v 'strict 'not-star))))
  (strict-quote*-expansion (lambda (v)
   (begin 
    (quote-expansion-raw v 'strict 'star))))
  (table-expansion (lambda (v)
   (letrec
    ((terms #f)
     (x (lambda (z)
      (begin 
              (cond ((not (null? z)) 
       (begin 
        (print output "(table-set! tmp ")
        (expand (car z))
        (print output " ")
        (expand (car (cdr z)))
        (print output ")")
        (x (cdr (cdr z))))) ) )))) 
    (begin 
     (set! terms (<term>-get-children (<term>-get-parent v)))
     (print output "(let ((tmp (make-table init: '__reserved-unbound-table-key))) (begin ")
     (x (cdr terms))
     (print output " tmp))")))))
  (if-expansion (lambda (v)
   (letrec
    ((terms #f)
     (test (lambda (t)
      (begin 
              (cond ((null? t) (noop)) ((null? (car t)) (noop))((string=? (<term>-get-value (car t)) "elsif:") 
       (begin 
        (print output "(")
        (expand (cadr t))
        (print output " ")
        (expand (caddr t))
        (print output ")")
        (test (cdddr t))))((string=? (<term>-get-value (car t)) "else:") 
       (begin 
        (print output "(else ")
        (expand (cadr t))
        (print output ")")
        (test (cddr t))))) )))) 
    (begin 
     (set! terms (<term>-get-children (<term>-get-parent v)))
     (print output (indent indentation) "(cond (")
     (expand (cadr terms))
     (print output " ")
     (expand (caddr terms))
     (print output ") ")
     (test (cdddr terms))
     (print output ") ")))))
  (repeat-expansion (lambda (v)
   (begin 
    #f)))
  (while-expansion (lambda (v)
   (letrec
    ((terms #f)) 
    (begin 
     (set! terms (<term>-get-children (<term>-get-parent v)))
     (print output (indent indentation) "(while ")
     (expand (cadr terms))
     (print output " ")
     (expand (caddr terms))
     (print output ")")))))
  (each-expansion (lambda (v)
   (letrec
    ((terms #f)) 
    (begin 
     (set! terms (<term>-get-children (<term>-get-parent v)))
     (print output (indent indentation) "(ginger-for-each ")
     (<group>-add-binding (<term>-get-parent v) #f (<term>-get-value (cadr terms)) (mangle (<term>-get-value (cadr terms))) 'argument)
     (print output (<term>-get-value (cadr terms)))
     (print output " ")
     (expand (caddr terms))
     (print output " ")
     (expand (cadddr terms))
     (print output ")")))))
  (begin-expansion (lambda (v)
   (letrec
    ((terms #f)
     (bindings #f)
     (first-term #f)) 
    (begin 
     (set! terms (<term>-get-children (<term>-get-parent v)))
     (set! bindings (<term>-get-bindings (<term>-get-parent v)))
     (set! first-term #t)
          (cond ((not (= (length bindings) 0)) 
     (begin 
      (println output "")
      (println output (indent indentation) "(letrec")
      (++! indentation)
      (print output (indent indentation) "(")
      (++! indentation)
            (ginger-for-each i bindings 
      (begin 
              (cond ((eq? (<binding>-get-type i) 'variable) 
       (begin 
                (cond (first-term 
        (begin 
         (set! first-term #f))) (else 
        (begin 
         (println output "")
         (print output (indent indentation))))) 
                (cond ((char=? (string-first (<binding>-get-export-name i)) ascii-pound) 
        (begin 
         (print output "(" (<binding>-get-name i) " " (<binding>-get-export-name i) ")"))) (else 
        (begin 
         (print output "(" (<binding>-get-name i) " #f)")))) )) ((eq? (<binding>-get-type i) 'function) 
       (begin 
                (cond (first-term 
        (begin 
         (set! first-term #f))) (else 
        (begin 
         (println output "")
         (print output (indent indentation))))) 
        (print output "(" (<binding>-get-export-name i) " ")
        (expand (car (<term>-get-children (<binding>-get-term i))))
        (print output ")")))) ))
      (print output ") ")
      (--! indentation))) ) 
     (println output "")
     (print output (indent indentation) "(begin ")
     (set! first-term #t)
          (ginger-for-each i (cdr terms) 
     (begin 
            (cond ((not (and (eq? (<term>-get-type (car (<term>-get-children i))) 'def) (= (length (<term>-get-children i)) 4))) 
      (begin 
       (println output "")
       (++! indentation)
       (print output (indent indentation))
       (expand i)
       (--! indentation))) ) ))
          (cond ((not (= (length bindings) 0)) 
     (begin 
      (--! indentation)
      (print output ")"))) ) 
     (print output ")")))))
  (call-expansion (lambda (v)
   (letrec
    ((terms #f)
     (b0 #f)) 
    (begin 
     (set! terms (<term>-get-children (<term>-get-parent v)))
     (set! b0 (<group>-get-binding (<term>-get-parent v) (<term>-get-value v)))
          (cond ((not b0) 
     (begin 
      (println "Error on line " line ", column " column ": Function '" (<term>-get-value v) "' was not found.")
      (exit))) ) 
     (print output "(" (<binding>-get-export-name b0))
          (ginger-for-each i (cdr terms) 
     (begin 
      (print output " ")
      (expand i)))
     (print output ")")))))
  (kall-expansion (lambda (v)
   (letrec
    ((terms #f)) 
    (begin 
     (set! terms (<term>-get-children (<term>-get-parent v)))
     (print output "(")
     (expand (car (cdr terms)))
     (print output " ")
     (expand (car (cdr (cdr terms))))
     (print output ")")))))
  (call2-expansion (lambda (v)
   (letrec
    ((terms #f)
     (b0 #f)) 
    (begin 
     (set! terms (<term>-get-children (<term>-get-parent v)))
     (set! b0 (<group>-get-binding (<term>-get-parent v) (<term>-get-value v)))
          (cond ((not b0) 
     (begin 
      (println "Error on line " line ", column " column ": Function '" (<term>-get-value v) "' was not found.")
      (exit))) ) 
     ((<binding>-get-expansion-function b0) v)))))
  (value-expansion (lambda (v)
   (begin 
    (print output (<term>-get-value v)))))
  (string-expansion (lambda (v)
   (begin 
    (print output "\"" (<term>-get-value v) "\""))))
  (quoted-symbol-expansion (lambda (v)
   (begin 
    (print output "'" (<term>-get-value v)))))
  (variable-expansion (lambda (v)
   (begin 
    (print output (<term>-get-value v)))))
  (symbol-expansion (lambda (v)
   (begin 
    (print output (<term>-get-value v)))))
  (argument-expansion (lambda (v)
   (begin 
    (print output (<term>-get-value v)))))
  (group-expansion (lambda (v)
   (letrec
    ((terms #f)) 
    (begin 
     (set! terms (<term>-get-children v))
          (cond ((eq? (<term>-get-type (car terms)) 'def) 
     (begin 
            (cond ((= (length terms) 3) 
      (begin 
       (expand (car terms)))) ) )) (else 
     (begin 
      (expand (car terms))))) ))))
  (head-expansion (lambda (v)
   (letrec
    ((terms #f)) 
    (begin 
     (set! terms (<term>-get-children v))
          (cond ((eq? compiler 'gambit) 
     (begin 
      (println output "#!/usr/bin/env gsi"))) (else 
     (begin 
      (println output "#!/usr/bin/env csi")))) 
     (println output "; This file contains code generated by the Ginger compiler.  Do not edit.")
     (println output "(include \"support.scm\")")
     (expand (car terms))))))
  (expand (lambda (v)
   (letrec
    ((type #f)) 
    (begin 
     (set! type (<term>-get-type v))
          (cond ((eq? type 'begin) (begin-expansion v)) ((eq? type 'def) (def-expansion v))((and (eq? type 'group) (not (<term>-get-parent v))) (head-expansion v))((eq? type 'group) (group-expansion v))((eq? type 'call) (call2-expansion v))((eq? type 'integer) (value-expansion v))((eq? type 'string) (string-expansion v))((eq? type 'quoted-symbol) (quoted-symbol-expansion v))((eq? type 'boolean) (value-expansion v))((eq? type 'symbol) (symbol-expansion v))(else (println output "EXPANSION ERROR, type " type ", " (<term>-get-value v)))) ))))
  (include-group-expansion (lambda (v)
   (letrec
    ((terms #f)) 
    (begin 
     (set! terms (<term>-get-children v))
          (ginger-for-each t terms 
     (begin 
      (include-expand t)))))))
  (include-expand (lambda (v)
   (letrec
    ((type #f)
     (value #f)) 
    (begin 
     (set! type (<term>-get-type v))
     (set! value (<term>-get-value v))
          (cond ((eq? type 'group) (include-group-expansion v)) ((and (eq? type 'symbol) (string=? value "include")) (include-expansion v))) ))))
  (<group>-get-local-binding (lambda (group name)
   (letrec
    ((b0 #f)) 
    (begin 
     (set! b0 #f)
          (ginger-for-each i (<term>-get-bindings group) 
     (begin 
            (cond ((string=? (<binding>-get-name i) name) 
      (begin 
       (set! b0 i))) ) ))
     b0))))
  (<group>-get-binding (lambda (group name)
   (letrec
    ((b0 #f)
     (p0 #f)) 
    (begin 
     (set! b0 (<group>-get-local-binding group name))
     (set! p0 (<term>-get-parent group))
          (cond ((not (not b0)) 
     (begin 
      b0)) (else 
     (begin 
            (cond ((not p0) 
      (begin 
       #f)) (else 
      (begin 
       (<group>-get-binding p0 name)))) ))) ))))
  (<group>-add-binding-with-expansion (lambda (group bound-group name export-name type expansion)
   (letrec
    ((b0 #f)) 
    (begin 
     
     (set! b0 (<binding>-new name export-name bound-group type expansion))
     (<term>-set-bindings group (append (<term>-get-bindings group) (list b0)))))))
  (<group>-add-binding (lambda (group bound-group name export-name type)
   (begin 
        (cond ((eq? type 'function) 
    (begin 
     (<group>-add-binding-with-expansion group bound-group name export-name type call-expansion))) ((eq? type 'intrinsic) 
    (begin 
     (<group>-add-binding-with-expansion group bound-group name export-name type call-expansion)))((eq? type 'argument) 
    (begin 
     (<group>-add-binding-with-expansion group bound-group name export-name type argument-expansion)))((eq? type 'variable) 
    (begin 
     (<group>-add-binding-with-expansion group bound-group name export-name type variable-expansion)))(else 
    (begin 
     #f))) )))
  (parse (lambda (input)
   (letrec
    ((c #f)
     (p #f)
     (buffer #f)
     (eos #f)
     (parse-indent #f)
     (is-quote #f)
     (first-term-on-line #f)) 
    (begin 
     (set! c #f)
     (set! p #f)
     (set! buffer "")
     (set! eos #f)
     (set! parse-indent -1)
     (set! is-quote 0)
     (set! first-term-on-line #t)
     (state-push 'begin)
          (while (not eos) 
     (begin 
            (cond ((eos? input) 
      (begin 
       (set! eos #t)
       (set! c ascii-space)
              (cond ((not (null? (paren-balanced))) 
       (begin 
        (println "Error in code block starting on line " (<term>-get-line tree-current) ": unbalanced parenthesis.")
        (exit))) ) )) (else 
      (begin 
       (set! c (get-char input))
              (cond ((and (char=? c ascii-cr) (char=? (peek-char input) ascii-lf)) 
       (begin 
        (set! c (get-char input)))) ) 
              (cond ((not (char-whitespace? c)) 
       (begin 
                (cond ((= parse-indent -1) 
        (begin 
         (set! parse-indent column))) ) )) ) ))) 
            (cond ((eq? (state-top) 'colon-quote) 
      (begin 
       (set! first-term-on-line #f)
              (cond ((or (char=? c ascii-left-parenthesis) (char=? c ascii-right-parenthesis) (char-eol? c) (eq? eos #t)) 
       (begin 
                (cond ((and (char=? p ascii-backslash) (not (char-eol? c))) 
        (begin 
         (set! buffer (substring buffer 0 (- (string-length buffer) 2)))
         (set! buffer (new-string buffer c)))) (else 
        (begin 
                  (cond ((char=? c ascii-left-parenthesis) 
         (begin 
          (tree-add (<value>-new 'string buffer line column))
          (set! buffer "")
          (paren-add)
          (tree-push)
          (<term>-set-parse-indent tree-current parse-indent)
          (state-push 'command))) ((or (char=? c ascii-right-parenthesis) (char-eol? c) (eq? eos #t)) 
         (letrec
          ((exit-colon-quote #f)) 
          (begin 
           (set! exit-colon-quote #f)
                      (cond ((not (char-eol? c)) 
           (begin 
            (set! exit-colon-quote #t)
                        (cond ((char=? c ascii-right-parenthesis) 
            (begin 
             (paren-remove)
                          (cond ((not (null? (paren-balanced))) 
             (begin 
                            (cond ((< (<term>-get-paren-balance (paren-balanced)) 0) 
              (begin 
               (println "Error in code block starting on line " (<term>-get-line tree-current) ": unbalanced parenthesis.")
               (exit))) ) )) ) )) ) )) (else 
           (letrec
            ((count #f)
             (undo-block-quote-check #f)) 
            (begin 
             (set! count 0)
             (set! undo-block-quote-check #f)
                          (cond ((= cbq-indent 0) 
             (begin 
                            (while (char=? (peek-char input) ascii-space) 
              (begin 
               (get-char input)
               (++! count)))
                            (cond ((> count (<term>-get-parse-indent tree-current)) 
              (begin 
               (set! cbq-indent count)
                              (cond ((not (= (string-length buffer) 0)) 
               (begin 
                (set! buffer (new-string buffer ascii-newline)))) ) )) (else 
              (begin 
               (set! undo-block-quote-check #t)
               (set! exit-colon-quote #t)))) )) (else 
             (begin 
                            (while (and (char=? (peek-char input) ascii-space) (< count cbq-indent)) 
              (begin 
               (get-char input)
               (++! count)))
                            (cond ((>= count cbq-indent) 
              (begin 
                              (cond ((not (= (string-length buffer) 0)) 
               (begin 
                (set! buffer (new-string buffer ascii-newline)))) ) )) (else 
              (begin 
               (set! cbq-indent 0)
               (set! undo-block-quote-check #t)
               (set! exit-colon-quote #t)))) ))) 
                          (cond (undo-block-quote-check 
             (begin 
                            (while (> count 0) 
              (begin 
               (unget-char input ascii-space)
               (--! count))))) ) )))) 
                      (cond (exit-colon-quote 
           (begin 
            (tree-add (<value>-new 'string buffer line column))
            (set! buffer "")
            (tree-pop)
            (tree-pop)
            (state-pop)
            (state-pop))) ) )))) ))) )) (else 
       (begin 
                (cond ((char=? c ascii-backslash) 
        (letrec
         ((dbs #f)) 
         (begin 
          (set! dbs (new-string c c))
          (set! buffer (new-string buffer dbs))))) (else 
        (begin 
         (set! buffer (new-string buffer c))))) ))) )) ((eq? (state-top) 'single-quote) 
      (begin 
              (cond ((or (char-whitespace? c) (char=? c ascii-right-parenthesis)) 
       (begin 
        (unget-char input c)
        (set! c ascii-space)
        (state-pop)
        (set! is-quote -1)
                (cond ((string=? buffer "") 
        (begin 
         (set! is-quote -2)
         (set! buffer "null"))) ) )) (else 
       (begin 
        (set! buffer (new-string buffer c))))) ))((eq? (state-top) 'double-quote) 
      (begin 
              (cond ((char=? p ascii-backslash) 
       (begin 
        (set! buffer (new-string buffer (char->double-quote-escape c)))
        (set! c ascii-space))) (else 
       (begin 
                (cond ((char=? c ascii-double-quote) 
        (begin 
         (state-pop)
         (set! is-quote 1)
                  (cond ((string=? buffer "") 
         (begin 
          (set! is-quote 2)
          (set! buffer "null"))) ) )) (else 
        (begin 
         (set! buffer (new-string buffer c))))) ))) ))((eq? (state-top) 'comment) 
      (begin 
              (cond ((char-eol? c) 
       (begin 
        (state-pop)
                (cond ((and (not (eq? (state-top) 'begin)) (not first-term-on-line)) 
        (begin 
         (unget-char input c)
         (set! c ascii-space))) ) )) ) ))((or (eq? (state-top) 'begin) (eq? (state-top) 'command)) 
      (begin 
              (cond ((char=? c ascii-semi-colon) 
       (begin 
        (state-push 'comment))) ((char=? c ascii-double-quote) 
       (begin 
        (state-push 'double-quote)))((char=? c ascii-single-quote) 
       (begin 
        (state-push 'single-quote)))((or (char=? c ascii-left-parenthesis) (char=? c ascii-right-parenthesis) (char-whitespace? c)) 
       (begin 
                (cond ((char=? c ascii-left-parenthesis) 
        (begin 
                  (cond ((and (string=? buffer ":") (= is-quote 0)) 
         (begin 
          (println "Error on line " line ", column " column ": illegal colon-quote.")
          (exit))) (else 
         (begin 
          (set! buffer "(")))) )) ) 
                (cond ((char=? c ascii-right-parenthesis) 
        (begin 
         (paren-remove)
                  (cond ((not (null? (paren-balanced))) 
         (begin 
                    (cond ((< (<term>-get-paren-balance (paren-balanced)) 0) 
          (begin 
           (println "Error in code block starting on line " (<term>-get-line tree-current) ": unbalanced parenthesis.")
           (exit))) ) )) ) )) ) 
                (cond ((and (char-whitespace? c) (not (char-eol? c)) (= (string-length buffer) 0)) 
        (begin 
         (noop))) (else 
        (begin 
                  (cond ((and (string=? buffer ":") (= is-quote 0)) 
         (begin 
                    (cond ((or (char=? ascii-space c) (char-eol? c) (char=? ascii-right-parenthesis c)) 
          (begin 
           (unget-char input c)
                      (cond ((char=? c ascii-right-parenthesis) 
           (begin 
            (paren-add)
            (unget-char input ascii-space))) (else 
           (begin 
            (set! buffer ":string-append")
            (set! p ascii-d)))) 
           (set! c ascii-space))) ) )) ((= (string-length buffer) 0) 
         (begin 
                    (cond ((char-eol? c) 
          (begin 
                      (cond ((and (not (eq? (state-top) 'begin)) (not first-term-on-line)) 
           (begin 
            (state-pop)
            (tree-pop))) ) )) ) 
                    (cond ((char=? c ascii-right-parenthesis) 
          (begin 
                      (cond ((= (tree-sibling-count) 0) 
           (begin 
            (<term>-set-parse-indent tree-current parse-indent))) ) 
           (state-pop)
           (tree-pop))) ) ))(else 
         (begin 
                    (cond ((eq? first-term-on-line #t) 
          (begin 
           (set! first-term-on-line #f)
                      (cond ((> (string-length buffer) 0) 
           (begin 
                        (cond ((< (<term>-get-parse-indent tree-current) parse-indent) 
            (begin 
                          (cond ((not (null? (paren-balanced))) 
             (begin 
              (println "Error in code block starting on line " (<term>-get-line tree-current) ": unbalanced parenthesis.")
              (exit))) ) 
                          (cond ((string-ellipses? buffer) 
             (begin 
              (println "Error on line " line ", column " column ": illegal ellipses indentation.")
              (exit))) ) 
                          (cond ((string-label? buffer) 
             (begin 
              (println "Error on line " line ", column " column ": illegal label indentation. (" (<term>-get-parse-indent tree-current) ", " parse-indent ")")
              (exit))) ) 
             (set! tree-current (last (<term>-get-children tree-current)))
             (state-push 'command)
             (tree-push)
             (<term>-set-parse-indent tree-current parse-indent)
             (state-push 'begin)
             (tree-add (<begin>-new line column))
             (tree-push)
             (<term>-set-parse-indent tree-current parse-indent)
             (state-push 'command))) ((> (<term>-get-parse-indent tree-current) parse-indent) 
            (begin 
                          (while (< parse-indent (<term>-get-parse-indent tree-current)) 
             (begin 
                            (cond ((not (null? (paren-balanced))) 
              (begin 
               (println "Error in code block starting on line " (<term>-get-line (paren-balanced)) ": unbalanced parenthesis.")
               (exit))) ) 
              (tree-pop)
              (state-pop)))
             (tree-pop)
             (state-pop)
                          (cond ((not (= parse-indent (<term>-get-parse-indent tree-current))) 
             (begin 
              (println "Error on line " line ", column " column ": illegal indentation.")
              (println "[ " parse-indent ", " (<term>-get-parse-indent tree-current) "]")
              (exit))) ) 
                          (cond ((or (string-ellipses? buffer) (string-label? buffer)) 
             (begin 
              (tree-unpop)
              (state-push 'command))) (else 
             (begin 
              (tree-push)
              (<term>-set-parse-indent tree-current parse-indent)
              (state-push 'command)))) ))(else 
            (begin 
                          (cond ((or (string-ellipses? buffer) (string-label? buffer)) 
             (begin 
              (tree-unpop)
              (state-push 'command))) (else 
             (begin 
                            (cond ((not (null? (paren-balanced))) 
              (begin 
               (println "Error in code block starting on line " (<term>-get-line tree-current) ": unbalanced parenthesis.")
               (exit))) ) 
              (tree-push)
              (<term>-set-parse-indent tree-current parse-indent)
              (state-push 'command)))) ))) )) ) )) ) 
                    (cond ((= (tree-sibling-count) 0) 
          (begin 
           (<term>-set-parse-indent tree-current parse-indent))) ) 
                    (cond ((> is-quote 0) 
          (begin 
                      (cond ((= is-quote 2) 
           (begin 
            (set! buffer ""))) ) 
           (tree-add (<value>-new 'string buffer line column))
           (set! is-quote 0))) ((< is-quote 0) 
          (begin 
                      (cond ((= is-quote -2) 
           (begin 
            (set! buffer ""))) ) 
           (tree-add (<value>-new 'quoted-symbol buffer line column))
           (set! is-quote 0)))((string-intent-integer? buffer) 
          (begin 
           (tree-add (<value>-new 'integer (string->intent-integer buffer) line column))))((string-intent-rational? buffer) 
          (begin 
           (tree-add (<value>-new 'rational (string->intent-rational buffer) line column))))((string-intent-complex? buffer) 
          (begin 
           (tree-add (<value>-new 'rational (string->intent-complex buffer) line column))))((string-boolean? buffer) 
          (begin 
           (tree-add (<value>-new 'boolean (string->boolean buffer) line column))))((string-colon-command? buffer) 
          (begin 
           (tree-add (<value>-new 'symbol (string->intent-symbol (string-rest buffer)) line column))
           (tree-push)
           (tree-add (<value>-new 'symbol "string-append" line column))
           (state-push 'colon-quote)
                      (cond ((char-eol? c) 
           (begin 
            (unget-char input c)
            (set! c ascii-space))) (else 
           (begin 
                        (while (char=? ascii-space (peek-char input)) 
            (begin 
             (get-char input)))))) 
           (set! buffer "")))((string-label? buffer) 
          (begin 
           (tree-add (<value>-new 'label (string->label buffer) line column))))((string-intent-symbol? buffer) 
          (begin 
           (tree-add (<value>-new 'symbol (string->intent-symbol buffer) line column))))((string-ellipses? buffer) 
          (begin 
                      (cond ((= (<term>-get-line tree-current) 0) 
           (begin 
            (println "Error on line " line ", column " column ": illegal ellipses.")
            (exit))) ) 
           (noop)))((char=? c ascii-left-parenthesis) 
          (begin 
           (paren-add)
           (tree-push)
           (<term>-set-parse-indent tree-current parse-indent)
           (state-push 'command)))(else 
          (begin 
           (println "Error on line " line ", column " column ": invalid symbol '" buffer "'.")
           (exit)))) 
                    (cond ((char-eol? c) 
          (begin 
                      (cond ((not (eq? (state-top) 'begin)) 
           (begin 
            (state-pop)
            (tree-pop))) ) )) ) 
                    (cond ((char=? c ascii-right-parenthesis) 
          (begin 
           (state-pop)
           (tree-pop))) ) 
          (set! buffer "")))) ))) ))(else 
       (begin 
        (set! buffer (new-string buffer c))))) ))) 
            (cond ((not (eof-object? input)) 
      (begin 
              (cond ((char-eol? c) 
       (begin 
        (set! line (+ line 1))
        (set! column 0)
        (set! parse-indent -1)
        (set! first-term-on-line #t))) (else 
       (begin 
        (set! column (+ column 1))))) )) ) 
      (set! p c)))))))
  (insert-bindings (lambda (g0)
   (letrec
    ((c0 #f)
     (p0 #f)) 
    (begin 
     (set! c0 (<term>-get-children g0))
     (set! p0 (<term>-get-parent g0))
          (ginger-for-each t1 c0 
     (begin 
            (cond ((eq? (<term>-get-type t1) 'group) 
      (begin 
       (insert-bindings t1))) (else 
      (begin 
              (cond ((eq? (<term>-get-type t1) 'symbol) 
       (begin 
                (cond ((string=? (<term>-get-value t1) "quote") 
        (begin 
         (noop))) ((string=? (<term>-get-value t1) "define") 
        (letrec
         ((name #f)) 
         (begin 
          (set! name (car (cdr c0)))
                    (cond ((= (length c0) 4) 
          (letrec
           ((arguments #f)
            (code #f)
            (b1 #f)) 
           (begin 
            (set! arguments (car (cdr (cdr c0))))
            (set! code (car (cdr (cdr (cdr c0)))))
            (set! b1 #f)
                        (cond ((not (eq? (<term>-get-type name) 'symbol)) 
            (begin 
             (println "Error on line " (<term>-get-line name) ", column " (<term>-get-column name) ": Illegal definition.")
             (exit))) ) 
                        (ginger-for-each t2 (<term>-get-children arguments) 
            (letrec
             ((b0 #f)) 
             (begin 
              (set! b0 (<group>-add-binding g0 code (<term>-get-value t2) (mangle (<term>-get-value t2)) 'argument))
                            (cond ((not b0) 
              (begin 
               (println "Error on line " (<term>-get-line t2) ", column " (<term>-get-column t2) ": duplicate binding.")
               (exit))) ) 
              (<term>-set-type t2 'argument))))
            (<term>-set-type t1 'def)
            (set! b1 (<group>-add-binding p0 g0 (<term>-get-value name) (mangle (<term>-get-value name)) 'function))
                        (cond ((not b1) 
            (begin 
             (println "Error on line " (<term>-get-line name) ", column " (<term>-get-column name) ": duplicate binding.")
             (exit))) ) ))) ((= (length c0) 3) 
          (letrec
           ((b0 #f)) 
           (begin 
            (<term>-set-type t1 'def)
                        (cond ((not (eq? (<term>-get-type name) 'symbol)) 
            (begin 
             (println "Error on line " (<term>-get-line name) ", column " (<term>-get-column name) ": Illegal definition.")
             (exit))) ) 
            (set! b0 (<group>-add-binding p0 g0 (<term>-get-value name) (mangle (<term>-get-value name)) 'variable))
                        (cond ((not b0) 
            (begin 
             (println "Error on line " (<term>-get-line name) ", column " (<term>-get-column name) ": duplicate binding.")
             (exit))) ) )))(else 
          (begin 
           (println "Error on line " (<term>-get-line name) ", column " (<term>-get-column name) ": ill-formed definition.")
           (exit)))) )))) )) ) ))) ))))))
  (insert-calls (lambda (tree this-quote)
   (letrec
    ((c0 #f)
     (p0 #f)
     (next-quote #f)) 
    (begin 
     (set! c0 (<term>-get-children tree))
     (set! p0 (<term>-get-parent tree))
     (set! next-quote this-quote)
          (cond ((not (null? c0)) 
     (begin 
            (cond ((and (eq? (<term>-get-type (car c0)) 'symbol) (string=? (<term>-get-value (car c0)) "quote")) 
      (begin 
       (set! next-quote #t))) ) 
            (cond ((and (eq? (<term>-get-type (car c0)) 'symbol) (string=? (<term>-get-value (car c0)) "unquote")) 
      (begin 
       (set! next-quote #f))) ) 
            (ginger-for-each t1 c0 
      (begin 
              (cond ((eq? (<term>-get-type t1) 'group) 
       (begin 
        (insert-calls t1 next-quote))) (else 
       (begin 
                (cond ((and (and (eq? this-quote #f) (eq? (<term>-get-type t1) 'symbol)) (eq? t1 (car c0))) 
        (begin 
         (<term>-set-type t1 'call))) ) ))) )))) ) ))))
  (compiler #f)
  (print-debug-tree #f)
  (compile #f)
  (print-version (lambda ()
   (letrec
    ((ginger-version #f)) 
    (begin 
     (set! ginger-version "20071009")
     (println "")
     (println "This is ginger, version " ginger-version ".")
     (println "")
     (println "Copyright 2007, James Dean Palmer")
     (println "")
     (println "Complete document for Ginger, including Frequently Asked Questions")
     (println "can be found at http://ginger.tiger3k.com/")))))
  (process-arguments (lambda (args)
   (begin 
        (cond ((not (null? args)) 
    (begin 
          (cond ((string=? (car args) "--version") 
     (begin 
      (print-version)
      (exit))) ((string=? (car args) "--compile") 
     (begin 
      (set! compile #t)
      (process-arguments (cdr args))))((string=? (car args) "--print-debug-tree") 
     (begin 
      (set! print-debug-tree #t)
      (process-arguments (cdr args))))((string=? (car args) "--gambit") 
     (begin 
      (set! compiler 'gambit)
      (process-arguments (cdr args))))((string=? (car args) "--chicken") 
     (begin 
      (set! compiler 'chicken)
      (process-arguments (cdr args))))((string=? (car args) "-o") 
     (begin 
      (set! output-file-name (car (cdr args)))
      (process-arguments (cdr (cdr args)))))(else 
     (begin 
      (set! input-file-name (car args))
      (process-arguments (cdr args))))) )) ) )))
  (comp #f)
  (base-file-name #f)
  (input #f)) 
 (begin 
  (set! banner "This is ginger, Version 20080216")
  (set! output #f)
  (set! output-file-name #f)
  (set! input-file-name #f)
  (set! last-char #f)
  (set! line 1)
  (set! column 0)
  (set! cbq-indent 0)
  (set! indentation 0)
  (set! tree-head (<group>-new 0 0))
  (set! tree-current tree-head)
  (set! state-stack (list))
  (tree-add (<begin>-new 0 0))
  (<group>-add-binding-with-expansion tree-head #f "if" #f 'intrinsic if-expansion)
  (<group>-add-binding-with-expansion tree-head #f "class" #f 'intrinsic class-expansion)
  (<group>-add-binding-with-expansion tree-head #f "repeat" #f 'intrinsic repeat-expansion)
  (<group>-add-binding-with-expansion tree-head #f "while" #f 'intrinsic while-expansion)
  (<group>-add-binding-with-expansion tree-head #f "each" #f 'intrinsic each-expansion)
  (<group>-add-binding-with-expansion tree-head #f "doc" #f 'intrinsic doc-expansion)
  (<group>-add-binding-with-expansion tree-head #f "require" #f 'intrinsic require-expansion)
  (<group>-add-binding-with-expansion tree-head #f "ensure" #f 'intrinsic ensure-expansion)
  (<group>-add-binding-with-expansion tree-head #f "kall" #f 'intrinsic kall-expansion)
  (<group>-add-binding-with-expansion tree-head #f "table" #f 'intrinsic table-expansion)
  (<group>-add-binding-with-expansion tree-head #f "quote" #f 'intrinsic quote-expansion)
  (<group>-add-binding-with-expansion tree-head #f "strict-quote" #f 'intrinsic strict-quote-expansion)
  (<group>-add-binding-with-expansion tree-head #f "quote*" #f 'intrinsic quote*-expansion)
  (<group>-add-binding-with-expansion tree-head #f "strict-quote*" #f 'intrinsic strict-quote*-expansion)
    (ginger-for-each i 
  (begin 
   (list (list "print" "print" ) (list "set" "set!" ) (list "println" "println" ) (list "getenv" "getenv" ) (list "file-exists?" "file-exists?" ) (list "getenv" "getenv" ) (list "file-exists?" "file-exists?" ) (list "pair" "cons" ) (list "first" "car" ) (list "last" "last" ) (list "head" "ginger-head" ) (list "tail" "cdr" ) (list "cadr" "cadr" ) (list "caddr" "caddr" ) (list "cadddr" "cadddr" ) (list "cdddr" "cdddr" ) (list "cddr" "cddr" ) (list "set-first" "set-car!" ) (list "set-tail" "set-cdr!" ) (list "null?" "null?" ) (list "list?" "list?" ) (list "list" "list" ) (list "length" "length" ) (list "append" "append" ) (list "reverse" "reverse" ) (list "list-tail" "list-tail" ) (list "list-ref" "list-ref" ) (list "memq" "memq" ) (list "memv" "memv" ) (list "member" "member" ) (list "assq" "assq" ) (list "assv" "assv" ) (list "assoc" "assoc" ) (list "table-key?" "table-key?" ) (list "table-set" "table-set!" ) (list "table-get" "table-ref" ) (list "symbol?" "symbol?" ) (list "symbol->string" "symbol->string" ) (list "string->symbol" "string->symbol" ) (list "char?" "char?" ) (list "char=?" "char=?" ) (list "char<?" "char<?" ) (list "char>?" "char>?" ) (list "char<=?" "char<=?" ) (list "char>=?" "char>=?" ) (list "char-ci=?" "char-ci=?" ) (list "char-ci<?" "char-ci<?" ) (list "char-ci>?" "char-ci>?" ) (list "char-ci<=?" "char-ci<=?" ) (list "char-ci>=?" "char-ci>=?" ) (list "char-alphabetic?" "char-alphabetic?" ) (list "char-numeric?" "char-numeric?" ) (list "char-whitespace?" "char-whitespace?" ) (list "char-upper-case?" "char-upper-case?" ) (list "char-lower-case?" "char-lower-case?" ) (list "char->integer" "char->integer" ) (list "integer->char" "integer->char" ) (list "char-upcase" "char-upcase" ) (list "char-downcase" "char-downcase" ) (list "eqv?" "eqv?" ) (list "eq?" "eq?" ) (list "equal?" "equal?" ) (list "number?" "number?" ) (list "complex?" "complex?" ) (list "real?" "real?" ) (list "rational?" "rational?" ) (list "integer?" "integer?" ) (list "exact?" "exact?" ) (list "inexact?" "inexact?" ) (list "zero?" "zero?" ) (list "positive?" "positive?" ) (list "negative?" "negative?" ) (list "odd?" "odd?" ) (list "even?" "even?" ) (list "max" "max" ) (list "min" "min" ) (list "exp" "exp" ) (list "log" "log" ) (list "sin" "sin" ) (list "cos" "cos" ) (list "tan" "tan" ) (list "asin" "asin" ) (list "acos" "acos" ) (list "atan" "atan" ) (list "sqrt" "sqrt" ) (list "expt" "expt" ) (list "make-rectangular" "make-rectangular" ) (list "make-polar" "make-polar" ) (list "real-part" "real-part" ) (list "imag-part" "imag-part" ) (list "magnitude" "magnitude" ) (list "angle" "angle" ) (list "exact->inexact" "exact->inexact" ) (list "inexact->exact" "inexact->exact" ) (list "number->string" "number->string" ) (list "string->number" "string->number" ) (list "+" "+" ) (list "-" "-" ) (list "*" "*" ) (list "/" "/" ) (list "modulo" "modulo" ) (list "remainder" "remainder" ) (list "quotient" "quotient" ) (list "numerator" "numerator" ) (list "denomenator" "denomenator" ) (list "lcm" "lcm" ) (list "gcd" "gcd" ) (list "floor" "floor" ) (list "ceiling" "ceiling" ) (list "truncate" "truncate" ) (list "round" "round" ) (list "=" "=" ) (list "<=" "<=" ) (list ">=" ">=" ) (list "<" "<" ) (list ">" ">" ) (list "++" "++!" ) (list "--" "--!" ) (list "string?" "string?" ) (list "make-string" "make-string" ) (list "string" "string" ) (list "string-append" "string-append" ) (list "string-length" "string-length" ) (list "string-ref" "string-ref" ) (list "string-set" "string-set!" ) (list "string=?" "string=?" ) (list "string-ci=?" "string-ci=?" ) (list "substring" "substring" ) (list "string->list" "string->list" ) (list "list->string" "list->string" ) (list "string-copy" "string-copy" ) (list "string-fill" "string-fill!" ) (list "string-split" "string-split" ) (list "string-join" "string-join" ) (list "vector?" "vector?" ) (list "make-vector" "make-vector" ) (list "vector" "vector" ) (list "vector-length" "vector-length" ) (list "vector-get" "vector-ref" ) (list "vector-set" "vector-set!" ) (list "vector->list" "vector->list" ) (list "list->vector" "list->vector" ) (list "vector-fill" "vector-fill!" ) (list "procedure?" "procedure?" ) (list "boolean?" "boolean?" ) (list "not" "not" ) (list "or" "or" ) (list "and" "and" ) (list "read-char" "read-char" ) (list "input-stream?" "input-port?" ) (list "eos-object?" "eof-object?" ) (list "open-input-file" "open-input-file" ) (list "open-output-file" "open-output-file" ) (list "close-input-stream" "close-input-port" ) (list "close-output-stream" "close-output-port" ) (list "peek-char" "peek-char" ) (list "open-string" "open-string" ) (list "open-input-string" "open-input-string" ) (list "open-output-string" "open-output-string" ) (list "get-output-string" "get-output-string" ) (list "exit" "exit" ) (list "scheme-eval" "eval" ) (list "scheme-read" "read" ) )) 
  (begin 
   (<group>-add-binding tree-head #f (car i) (last i) 'intrinsic)))
    (ginger-for-each i (list 'a 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's 't 'u 'v 'w 'x 'y 'z 'A 'B 'C 'D 'E 'F 'G 'H 'I 'J 'K 'L 'M 'N 'O 'P 'Q 'R 'S 'T 'U 'V 'W 'X 'Y 'Z ) 
  (begin 
   (<group>-add-binding tree-head #f (string-append "ascii-" (symbol->string i)) (string-append "#\\" (symbol->string i)) 'variable)))
    (ginger-for-each i (list 0 1 2 3 4 5 6 7 8 9 ) 
  (begin 
   (<group>-add-binding tree-head #f (string-append "ascii-" (number->string i)) (string-append "#\\" (number->string i)) 'variable)))
    (ginger-for-each i 
  (begin 
   (list (list "ascii-newline" "#\\newline" ) (list "ascii-tab" "#\\tab" ) (list "ascii-space" "#\\space" ) (list "ascii-period" "#\\." ) (list "ascii-slash" "#\\/" ) (list "ascii-backslash" "#\\\\" ) (list "ascii-left-parenthesis" "#\\(" ) (list "ascii-right-parenthesis" "#\\)" ) (list "ascii-underscore" "#\\_" ) (list "ascii-plus" "#\\+" ) (list "ascii-minus" "#\\-" ) (list "ascii-mult" "#\\*" ) (list "ascii-dollar" "#\\$" ) (list "ascii-at" "#\\@" ) (list "ascii-percent" "#\\%" ) (list "ascii-exclamation" "#\\!" ) (list "ascii-less-than" "#\\<" ) (list "ascii-greater-than" "#\\>" ) (list "ascii-question" "#\\?" ) (list "ascii-colon" "#\\:" ) (list "ascii-semi-colon" "#\\;" ) (list "ascii-single-quote" "#\\'" ) (list "ascii-double-quote" "#\\\"" ) (list "ascii-equals" "#\\=" ) (list "ascii-pound" "#\\#" ) (list "ascii-return" "#\\return" ) (list "ascii-nul" "#\\nul" ) (list "ascii-cr" "#\\return" ) (list "ascii-lf" "#\\newline" ) )) 
  (begin 
   (<group>-add-binding tree-head #f (car i) (last i) 'variable)))
  (println "Gingerbread: The Ginger compiler")
  (set! compiler 'gambit)
  (set! print-debug-tree #f)
  (set! compile #f)
  (process-arguments (cdr (command-line)))
    (cond ((eq? compiler 'gambit) 
  (begin 
   (<group>-add-binding tree-head #f "argv" "command-line" 'intrinsic)
   (<group>-add-binding tree-head #f "execute" "shell-command" 'intrinsic))) ((eq? compiler 'chicken) 
  (begin 
   (<group>-add-binding tree-head #f "argv" "argv" 'intrinsic)
   (<group>-add-binding tree-head #f "execute" "system" 'intrinsic)))) 
    (cond ((not input-file-name) 
  (begin 
   (println "Error: no input file")
   (exit))) ) 
  (set! comp (string-split input-file-name ascii-period))
  (set! base-file-name (string-join (reverse (cdr (reverse comp))) "."))
    (cond ((not output-file-name) 
  (begin 
   (set! output-file-name (string-append base-file-name ".scm")))) ) 
  (println "Gingerbread: Opening file..")
  (println "Parsing " input-file-name)
  (set! input (open-input-file input-file-name))
  (parse input)
  (close-input-port input)
    (cond (print-debug-tree 
  (begin 
   (print-term tree-head))) ) 
  (println "Expand includes..")
  (include-expand tree-head)
  (println "Inserting bindings..")
  (insert-bindings tree-head)
  (println "Inserting immutable calls..")
  (insert-calls tree-head #f)
  (set! output (open-output-file output-file-name))
  (println "Writing code..")
  (expand tree-head)
  (close-output-port output)
    (cond ((eq? compile #t) 
  (begin 
      (cond ((eq? compiler 'chicken) 
   (begin 
    (println "Compiling with Chicken.")
    (shell-command (string-append "csc -d0 -O3 -no-trace -block " output-file-name)))) ((eq? compiler 'gambit) 
   (begin 
    (println "Compiling with Gambit.")
    (shell-command (string-append "gsc -debug -link -cc-options \"-U___SINGLE_HOST -O2\" " base-file-name))
    (shell-command (string-append "gcc -O3 -I/Library/Gambit-C/current/include -L/Library/Gambit-C/current/lib " base-file-name ".c " base-file-name "_.c -lgambc -o " base-file-name))))) )) ) 
  (println "All Done!")))
