; Copyright 2009 by James Dean Palmer and others.
;
; Licensed under the Apache License, Version 2.0 (the "License"); 
; you may not use this file except in compliance with the License. 
; You may obtain a copy of the License at 
;
;   http://www.apache.org/licenses/LICENSE-2.0 
;
; Unless required by applicable law or agreed to in writing, software 
; distributed under the License is distributed on an "AS IS" BASIS, 
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
; See the License for the specific language governing permissions and 
; limitations under the License. 
;
; Please report all bugs and problems to "bugs@ging3r.org".

inline-c-header "#include <math.h>"
inline-c-header "#include <ctype.h>"

;;; TYPE support
;;;
;;; Ginger supports several fundamental types:
;;; Boolean, Char, Cons, Flonum, Function, Port, Number, String, Symbol, Vector

; We begin by bootstrapping the type system.

; TODO - remove this after the next build..  It's now part of compile.gin
define null (inline-c result " = GIN_NULL;")

define Ginger::type-table false

define Type false
inline-c "GIN_ALLOCATE(" Type ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" Type "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" Type "))->index = GIN_TYPE_TYPE;"

define Cons false
inline-c "GIN_ALLOCATE(" Cons ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" Cons "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" Cons "))->index = GIN_TYPE_CONS;"

define Integer false
inline-c "GIN_ALLOCATE(" Integer ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" Integer "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" Integer "))->index = GIN_TYPE_INTEGER;"

define Vector false
inline-c "GIN_ALLOCATE(" Vector ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" Vector "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" Vector "))->index = GIN_TYPE_VECTOR;"

define String false
inline-c "GIN_ALLOCATE(" String ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" String "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" String "))->index = GIN_TYPE_STR8;"

define Function false
inline-c "GIN_ALLOCATE(" Function ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" Function "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" Function "))->index = GIN_TYPE_FUNCTION;"

define Stream false
inline-c "GIN_ALLOCATE(" Stream ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" Stream "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" Stream "))->index = GIN_TYPE_STREAM;"

define String-Stream false
inline-c "GIN_ALLOCATE(" String-Stream ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" String-Stream "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" String-Stream "))->index = GIN_TYPE_STRING_STREAM;"

define Flonum false
inline-c "GIN_ALLOCATE(" Flonum ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" Flonum "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" Flonum "))->index = GIN_TYPE_FLONUM;"

define Dict false
inline-c "GIN_ALLOCATE(" Dict ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" Dict "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" Dict "))->index = GIN_TYPE_DICT;"

define DictCell false
inline-c "GIN_ALLOCATE(" DictCell ", GIN_OBJ, sizeof(GingerType));"
inline-c "((GingerType*)(" DictCell "))->type_index = GIN_TYPE_TYPE;"
inline-c "((GingerType*)(" DictCell "))->index = GIN_TYPE_DICT_CELL;"

inline-c "GIN_ALLOCATE_WITH_CLEANUP(" Ginger::type-table ", GIN_OBJ, sizeof(GingerVector));"
inline-c "type_table = " Ginger::type-table ";"
inline-c "GIN_ALLOCATE(((GingerVector*)(" Ginger::type-table "))->value, GIN_OBJ*, sizeof(GIN_OBJ)*11);"
inline-c "((GingerVector*)(" Ginger::type-table "))->type_index = GIN_TYPE_VECTOR;"
inline-c "((GingerVector*)(" Ginger::type-table "))->length = 11;"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[0] = " Type ";"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[1] = " Cons ";"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[2] = " Integer ";"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[3] = " Vector ";"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[4] = " String ";"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[5] = " Function ";"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[6] = " Stream ";"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[7] = " String-Stream ";"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[8] = " Flonum ";"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[9] = " Dict ";"
inline-c "((GingerVector*)(" Ginger::type-table "))->value[10] = " DictCell ";"

define Type make (name)
  define new-type false
  inline-c "GIN_ALLOCATE(" new-type ", GIN_OBJ, sizeof(GingerType));"
  inline-c "((GingerType*)(" new-type "))->type_index = GIN_TYPE_TYPE;"
  define len (Vector::length Ginger::type-table)
  inline-c "((GingerType*)(" new-type "))->index = " len ";"
;  inline-c "((GingerType*)(" new-type "))->make = 0;"
;  inline-c "((GingerType*)(" new-type "))->unmake = 0;"
  inline-c "((GingerType*)(" new-type "))->c_make = 0;"
  inline-c "((GingerType*)(" new-type "))->c_unmake = 0;"
  Vector::push Ginger::type-table new-type
  new-type

define Type index (self)
  inline-c result " = ((GingerType*)(" self "))->index;"

define Type eq? (a b)
  inline-c result "= GIN_IM_FROM_BOOL(" a " == " b ");"

define Type? (a)
  Type::eq? (type a) Type

; Now that the type system is bootstrapped, we can define other built-in types..

define! Symbol (Type::make "Symbol")   ; 11
define! Binary (Type::make "Binary")   ; 12
define! Boolean (Type::make "Boolean") ; 13
define! Null (Type::make "Null")       ; 14
define! Char (Type::make "Char")       ; 15
define! Bcons (Type::make "Bcons")
; define! Fixnum (Type::make "Fixnum")

define Ginger::immediate? (self)
  inline-c result " = GIN_IM_FROM_BOOL(GIN_IS_IM(" self "));"

define Ginger::im-type (self)
  ; Faster approach?
  ; 1. invert bits
  ; 2. BSF to get least significant one (platforms with clz would require reverse order)
  ; 3. Use result as index into table to get type
  define test false
  inline-c test " = GIN_IM_FROM_BOOL(GIN_IS_IM_INT(" self "));"
  if (test)
    Integer
  else:
    inline-c test " = GIN_IM_FROM_BOOL(GIN_IS_IM_SYM(" self "));"
    if (test)
      Symbol
    else:
      inline-c test " = GIN_IM_FROM_BOOL(GIN_IS_IM_BINARY(" self "));"
      if (test)
        Binary
      else:
        inline-c test " = GIN_IM_FROM_BOOL(GIN_IS_IM_CHAR16(" self "));"
        if (test)
          Char
        else:
          inline-c test " = GIN_IM_FROM_BOOL(GIN_IS_IM_CHAR8(" self "));"
          if (test)
            Char
          else:
            inline-c test " = GIN_IM_FROM_BOOL(GIN_IS_IM_BOOL(" self "));"
            if (test)
              Boolean
            else:
              Null

define Ginger::im->Binary (self)
  ; Faster approach?
  ; 1. invert bits
  ; 2. BSF to get least significant one (platforms with clz would require reverse order)
  ; 3. Shift right that many bits, use shift to compute goto to place in an appropriate binary
  define t (Ginger::im-type self)
  define r false
  if (Type::eq? t Integer)
    Integer->Binary self
  elsif: (Type::eq? t Symbol)
    Symbol->Binary self
  elsif: (Type::eq? t Binary)
    self
  elsif: (Type::eq? t Char)
    Char->Binary self
  elsif: (Type::eq? t Boolean)
    Boolean->Binary t
  elsif: (Type::eq? t Null)
    Null->Binary t

define Ginger::nim-type (self)
  inline-c result " = GIN_NIM_GET_TYPE(" self ");"

; type responds with the most exact type object

define! type (self)
  if (Ginger::immediate? self)
    Ginger::im-type self
  else:
    Vector::get Ginger::type-table (Ginger::nim-type self)

define type-of (term)
  ;inline-c result " = GIN_IM_FROM_INT(GIN_NIM_GET_TYPE(" term "));"
  if (Null? term) "null"
  elsif: (list? term) "list"
  elsif: (Cons? term) "cons"
  elsif: (String? term) "string"
  elsif: (Binary? term) "binary"
  elsif: (Function? term) "function"
  elsif: (Char? term) "char"
  elsif: (Boolean? term) "boolean"
  elsif: (Fixnum? term) "fixnum"
  elsif: (Integer? term) "integer"
  elsif: (Flonum? term) "flonum"
;  elsif: (Stream? term) "stream"
;  elsif: (String-Stream? term) "string-stream"
  elsif: (Vector? term) "vector"
  elsif: (Dict? term) "dict"
  elsif: (Symbol? term) "symbol"
  else: "foreign"

define object->string (term)
  define output ""

  if (Null? term) (set output (String::append output "null"))
  elsif: (list? term)
    set output (String::append output "(")
    each i term
      set output (String::append output (object->string i) " ")
    set output (String::append output ")")
  elsif: (Cons? term)
    set output (String::append output "(" (object->string (first term)) " . . " (object->string (second* term)) ")")
  elsif: (String? term) (set output (String::append output term))
  elsif: (Binary? term) (set output (String::append (Binary->String term)))
  elsif: (Function? term) (set output (String::append (Function->String term)))
  elsif: (Char? term) (set output (String::append (Char->String term)))
  elsif: (Boolean? term) (set output (String::append (Boolean->String term)))
  elsif: (Fixnum? term) (set output (String::append (Fixnum->String term)))
  elsif: (Integer? term) (set output (String::append (Fixnum->String term)))
  elsif: (Flonum? term) (set output (String::append (Flonum->String term)))
;  elsif: (Stream? term) (set output (String::append (Stream->String term)))
;  elsif: (String-Stream? term) (set output (String::append (String-Stream->String term)))
  elsif: (Vector? term) (set output (String::append (Vector->String term)))
  elsif: (Dict? term) (set output (String::append (Dict->String term)))
;  elsif: (Class? term) (set output (String::append (class-to-str term)))
  elsif: (Symbol? term) (set output (String::append (Symbol->String term)))
  else: (set output (String::append (Foreign->String term)))
  
  output

; TODO - should this be part of literate.gin?
;  that is the only place it is used so far
;  and there are a few things that are specific 
;  to literate.gin
define object->pretty-string (term)
  define list-count -1
  define parse-indent 0
  
  define object->pretty-string-internal (term)
    
    define output ""
    if (Null? term) (set output (String::append output "null"))
    elsif: (list? term)
      
      if (or (> (Dict::get (properties term) 'parse-indent) parse-indent)
      .. (< (Dict::get (properties term) 'parse-indent) parse-indent))
        set parse-indent (Dict::get (properties term) 'parse-indent)
        set list-count -1
        define i 0
        while (< i parse-indent)
          set output (String::append output " ")
          ++ i

      if (= list-count 0)
        set output (String::append output "\\n")
        
        define i 0
        while (< i parse-indent)
          set output (String::append output " ")
          ++ i

      if (> list-count 0)
        set output (String::append output "(")
      ++ list-count
      
      ; keep track of the number of terms and the current term 
      ;   that is being printed. we don't need a space if we are
      ;   on the last term.
      define num-terms (length term)
      define term-count 0

      ; save the if block's indention
      define if-block-indent 0
      if (eq? (first term) 'if)
        set if-block-indent (Dict::get (properties term) 'parse-indent)
      
      each i term
        
        ; add indention for these
        if (String? i)
          if (or (String::eq? i "else:") (String::eq? i "elsif:"))
            define inx 0
            while (< inx if-block-indent)
              set output (String::append output " ")
              ++ inx

        ++ term-count
        if (or (= term-count num-terms)
        .. (or (eq? (nth term (+ term-count 1)) "else:") (eq? (nth term (+ term-count 1)) "elsif:")))
          set output (String::append output (object->pretty-string-internal i))
        else:
          set output (String::append output (object->pretty-string-internal i) " ")
      
      -- list-count 
      if (= list-count -1)
        set output (String::append output "\\n")
      else:
        if (> list-count 0)
          set output (String::append output ")")

    elsif: (Cons? term)
      set output (String::append output 
      .. "(" 
      .. (object->pretty-string-internal (first term)) 
      .. " . . " 
      .. (object->pretty-string-internal (second* term))
      .. ")")
    elsif: (String? term) (set output (String::append output term))
    elsif: (Binary? term) (set output (String::append (Binary->String term)))
    elsif: (Function? term) (set output (String::append (Function->String term)))
    elsif: (Char? term) (set output (String::append (Char->String term)))
    elsif: (Boolean? term) (set output (String::append (Boolean->String term)))
    elsif: (Fixnum? term) (set output (String::append (Fixnum->String term)))
    elsif: (Integer? term) (set output (String::append (Fixnum->String term)))
    elsif: (Flonum? term) (set output (String::append (Flonum->String term)))
    ;elsif: (Stream? term) (set output (String::append (Stream->String term)))
    ;elsif: (String-Stream? term) (set output (String::append (String-Stream->String term)))
    elsif: (Vector? term) (set output (String::append (Vector->String term)))
    elsif: (Dict? term) (set output (String::append (Dict->String term)))
    ;elsif: (Class? term) (set output (String::append (class-to-str term)))
    elsif: (Symbol? term) 
      
      if (Symbol::eq? term '<)
        ; TODO - this only makes sense for printing to html or using pango
        ; we don't want to do this if we are printing to the shell or something else
        ; (this is a hack)
        set output (String::append "&lt;")
      else:
        set output (String::append (Symbol->String term))
        
    else: (set output (String::append (Foreign->String term)))
    
    output
  
  object->pretty-string-internal term

;;;
;;; CONSTANTS
;;;

; Now lets bootstrap the symbol systems
define Ginger::symbol->string (Vector::make)
define Ginger::string->symbol (Dict::make)

define Ginger::Symbol->Number (s)
  inline-c result " = GIN_IM_FROM_INT(GIN_IM_TO_SYM(" s "));"

; Does not check if string is a valid symbol.
define Ginger::String->Symbol (a)
  ; require (!= (length a) 0)
  if (= (String::length a) 1)
    define n (Char->Integer (String::nth a 0))
    inline-c n " = GIN_IM_FROM_SYM(GIN_IM_TO_INT(" n "));"
    n
  elsif: (not (false? (Dict::get Ginger::string->symbol a)))
    Dict::get Ginger::string->symbol a
  else:
    define n (+ (Vector::length Ginger::symbol->string) 2048)
    inline-c n " = GIN_IM_FROM_SYM(GIN_IM_TO_INT(" n "));"
    Dict::set Ginger::string->symbol a n
    Vector::push Ginger::symbol->string a
    n

define Ginger::Symbol->String (s)
  define n (Ginger::Symbol->Number s)
  ; assert n < Vector::length + 2048
  if (>= n 2048)
    Vector::get Ginger::symbol->string (- n 2048)
  else:
    if (< n 128)
      ; ascii.
      String::string (Integer->Char n)
    elsif: (< n 2047)
      ; 2 byte utf
      println "Not implemented."
      exit
    else:
      ; Reserved..
      println "Not implemented."
      exit

define Ginger::bootstrap-symbols ()
  define symbol-count 0
  define i 0
  inline-c symbol-count "=GIN_IM_FROM_INT(qsdef_count);"
  while (< i symbol-count)
    define s false
    inline-c "GIN_NEW_STR8(" s ",qsdef[GIN_IM_TO_INT(" i ")]);"
    Ginger::String->Symbol s
    ++ i

Ginger::bootstrap-symbols

; Similar to eqv? in Scheme.  No analogs of eq? or equal? are part of the Ginger std lib.
define eq? (a b)
  if (or (Ginger::immediate? a) (Ginger::immediate? b))
    inline-c result " = GIN_IM_FROM_BOOL(" a " == " b ");"
  else:
    if (and (Type? a) (Type? b))
      Type::eq? a b
    elsif: (and (Number? a) (Number? b))
      = a b
    elsif: (and (Symbol? a) (Symbol? b))
      Symbol::eq? a b
    elsif: (and (String? a) (String? b))
      String::eq? a b
    elsif: (and (Binary? a) (Binary? b))
      Binary::eq? a b
    elsif: (and (Char? a) (Char? b))
      Char::eq? a b
    elsif: (and (Boolean? a) (Boolean? b))
      inline-c result "= GIN_IM_FROM_BOOL(GIN_IM_TO_BOOL(" a ") == GIN_IM_TO_BOOL(" b "));"
    else:
      inline-c result "= GIN_IM_FROM_BOOL(" a " == " b ");"

;;; BINARY - UNTYPED MEMORY
;;;
;;; This is the most basic type.  Other datastructures may be defined in terms of Binaries

define Binary make (len)
  ; The require should be some kind of system related limit on len..
  ; Perhaps it should be related to Fixnum as I am not fond of binaries used to represent
  ; the length of even bigger binaries.  If based on 20bit Fixnum, that would give
  ; a maximum bit length of 2097151 or approx. 262KB which seems fairly reasonable.
  require (Ginger::immediate? len)
  define r false
  if (> len 25)
    define byte-len false
    define t (Type::index Binary)
    inline-c "if ((GIN_IM_TO_INT(" len ") % 8) == 0) { " byte-len " = GIN_IM_FROM_INT(GIN_IM_TO_INT(" len ")/8); } else { " byte-len " = GIN_IM_FROM_INT((GIN_IM_TO_INT(" len ")/8)+1); }"
    inline-c "GIN_ALLOCATE(" r ",void*,sizeof(GingerBinary)+GIN_IM_TO_INT(" byte-len "));"
    inline-c "GIN_NIM_GET_TYPE(" r ") = " t ";"
    inline-c "((GingerBinary*)" r ")->length = GIN_IM_TO_INT(" len ");"
  else:
    inline-c r " = GIN_IM_FROM_BINARY(0, GIN_IM_TO_INT(" len "));"
  r

define Binary? (a)
  if (Ginger::immediate? a)
    inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_IM_BINARY(" a "));"
  else:
    if (Type::eq? (type a) Binary)
      true
    else:
      false

define Binary->Integer (a)
  if (Ginger::immediate? a)
    inline-c result "= GIN_IM_FROM_INT(GIN_IM_TO_BINARY_SIGNED(" a "));"
  else:
    0

define Binary length (a)
  if (Ginger::immediate? a)
    inline-c result "= GIN_IM_FROM_INT(GIN_IM_TO_BINARY_LENGTH(" a "));"
  else:
    inline-c result "= GIN_IM_FROM_INT(((GingerBinary*)" a ")->length);"

define Binary + (a b)
  define len 0
  define len-a (Binary::length a)
  define len-b (Binary::length b)
  inline-c "if (GIN_IM_TO_INT(" len-a ") > GIN_IM_TO_INT(" len-b ")) { " len " = " len-a "; } else { " len " = " len-b "; };"
  define r (Binary::make len)
  if (and (Ginger::immediate? a) (Ginger::immediate? b))
    inline-c r " = GIN_IM_FROM_BINARY((GIN_IM_TO_BINARY_SIGNED(" a ") + GIN_IM_TO_BINARY_SIGNED(" b ")),GIN_IM_TO_INT(" len "));"
    r
  else:
    define d 0
    define a-d 0
    define b-d 0
    inline-c d " = GIN_IM_FROM_INT((GIN_IM_TO_INT(" len ") / 32) + 1);"
    inline-c a-d " = GIN_IM_FROM_INT((GIN_IM_TO_INT(" len-a ") / 32) + 1);"
    inline-c b-d " = GIN_IM_FROM_INT((GIN_IM_TO_INT(" len-b ") / 32) + 1);"
    define k 0
    ; sign = 0 - should be positive
    ; sign = 1 - should be negative
    ; sign = 2 - don't care
    define sign 0
    define accum 0

    if (and (not (Ginger::immediate? a)) (Ginger::immediate? b))
      noop
      false
    elsif: (and (Ginger::immediate? a) (not (Ginger::immediate? b)))
      noop
      false
    else:
      inline-c " for (" k "= GIN_IM_FROM_INT(0); GIN_IM_TO_INT(" k ") < GIN_IM_TO_INT(" d "); " k " = GIN_IM_FROM_INT(GIN_IM_TO_INT(" k ") + 1)) { \
        if ((((GingerBinary*)" a ")->value[GIN_IM_TO_INT(" k ")] > 0) && \
            (((GingerBinary*)" b ")->value[GIN_IM_TO_INT(" k ")] > 0)) " sign " = GIN_IM_FROM_INT(0); \
        else if ((((GingerBinary*)" a ")->value[GIN_IM_TO_INT(" k ")] < 0) && \
            (((GingerBinary*)" b ")->value[GIN_IM_TO_INT(" k ")] < 0)) " sign " = GIN_IM_FROM_INT(1); \
        else " sign " = GIN_IM_FROM_INT(2); \
        if ((GIN_IM_TO_INT(" a-d ") > 0) && (GIN_IM_TO_INT(" b-d ") > 0)) { \
          ((GingerBinary*)" r ")->value[GIN_IM_TO_INT(" k ")] = \
            ((GingerBinary*)" a ")->value[GIN_IM_TO_INT(" k ")] + \
            ((GingerBinary*)" b ")->value[GIN_IM_TO_INT(" k ")] + GIN_IM_TO_INT(" accum "); \
        } \
        if ((GIN_IM_TO_INT(" a-d ") > 0) && (GIN_IM_TO_INT(" b-d ") == 0)) { \
          ((GingerBinary*)" r ")->value[GIN_IM_TO_INT(" k ")] = \
            ((GingerBinary*)" a ")->value[GIN_IM_TO_INT(" k ")] + GIN_IM_TO_INT(" accum "); \
        } \
        if ((GIN_IM_TO_INT(" a-d ") == 0) && (GIN_IM_TO_INT(" b-d ") > 0)) { \
          ((GingerBinary*)" r ")->value[GIN_IM_TO_INT(" k ")] = \
            ((GingerBinary*)" b ")->value[GIN_IM_TO_INT(" k ")] + GIN_IM_TO_INT(" accum "); \
        } \
        " accum " = GIN_IM_FROM_INT(0); \
        if ((((GingerBinary*)" r ")->value[GIN_IM_TO_INT(" k ")] < 0) && (GIN_IM_TO_INT( " sign " ) == 0)) " accum " = GIN_IM_FROM_INT(1); \
        if ((((GingerBinary*)" r ")->value[GIN_IM_TO_INT(" k ")] > 0) && (GIN_IM_TO_INT( " sign " ) == 1)) " accum " = GIN_IM_FROM_INT(1); \
        " a-d " = GIN_IM_FROM_INT(GIN_IM_TO_INT(" a-d ") - 1); \
        " b-d " = GIN_IM_FROM_INT(GIN_IM_TO_INT(" b-d ") - 1); \
      };"
      r

define Binary - (a b)
  define len 0
  define len-a (Binary::length a)
  define len-b (Binary::length b)
  inline-c "if (GIN_IM_TO_INT(" len-a ") > GIN_IM_TO_INT(" len-b ")) { " len " = " len-a "; } else { " len " = " len-b "; };"
  define r (Binary::make len)
  if (and (Ginger::immediate? a) (Ginger::immediate? b))
    inline-c r " = GIN_IM_FROM_BINARY((GIN_IM_TO_BINARY(" a ") - GIN_IM_TO_BINARY(" b ")),GIN_IM_TO_INT(" len "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary * (a b)
  define len (max (Binary::length a) (Binary::length b))
  if (and (Ginger::immediate? a) (Ginger::immediate? b))
    inline-c result " = GIN_IM_FROM_BINARY((GIN_IM_TO_BINARY(" a ") * GIN_IM_TO_BINARY(" b ")),GIN_IM_TO_INT(" len "));"
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary / (a b)
  define len (max (Binary::length a) (Binary::length b))
  if (and (Ginger::immediate? a) (Ginger::immediate? b))
    inline-c result " = GIN_IM_FROM_BINARY((GIN_IM_TO_BINARY(" a ") / GIN_IM_TO_BINARY(" b ")),GIN_IM_TO_INT(" len "));"
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary > (a b)
  if (and (Ginger::immediate? a) (Ginger::immediate? b))
    define r false
    inline-c r " = GIN_IM_FROM_BOOL(GIN_IM_TO_BINARY_SIGNED(" a ") > GIN_IM_TO_BINARY_SIGNED(" b "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary >= (a b)
  if (and (Ginger::immediate? a) (Ginger::immediate? b))
    define r false
    inline-c r " = GIN_IM_FROM_BOOL(GIN_IM_TO_BINARY_SIGNED(" a ") >= GIN_IM_TO_BINARY_SIGNED(" b "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary < (a b)
  if (and (Ginger::immediate? a) (Ginger::immediate? b))
    define r false
    inline-c r " = GIN_IM_FROM_BOOL(GIN_IM_TO_BINARY_SIGNED(" a ") < GIN_IM_TO_BINARY_SIGNED(" b "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary <= (a b)
  if (and (Ginger::immediate? a) (Ginger::immediate? b))
    define r false
    inline-c r " = GIN_IM_FROM_BOOL(GIN_IM_TO_BINARY_SIGNED(" a ") <= GIN_IM_TO_BINARY_SIGNED(" b "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary eq? (a b)
  if (and (Ginger::immediate? a) (Ginger::immediate? b))
    define r false
    inline-c r " = GIN_IM_FROM_BOOL(GIN_IM_TO_BINARY_SIGNED(" a ") == GIN_IM_TO_BINARY_SIGNED(" b "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary != (a b)
  if (and (Ginger::immediate? a) (Ginger::immediate? b))
    define r false
    inline-c r " = GIN_IM_FROM_BOOL(GIN_IM_TO_BINARY_SIGNED(" a ") != GIN_IM_TO_BINARY_SIGNED(" b "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary << (a amt)
  if (Ginger::immediate? a)
    define len-a (Binary::length a)
    define r false
    inline-c r " = GIN_IM_FROM_BINARY(GIN_IM_TO_BINARY(" a ") << GIN_IM_TO_INT(" amt "), GIN_IM_TO_INT(" len-a "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary <<< (a amt)
  if (Ginger::immediate? a)
    define len-a (Binary::length a)
    define r false
    inline-c r " = GIN_IM_FROM_BINARY(GIN_IM_TO_BINARY_SIGNED(" a ") << GIN_IM_TO_INT(" amt "), GIN_IM_TO_INT(" len-a "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary >> (a amt)
  if (Ginger::immediate? a)
    define len-a (Binary::length a)
    define r false
    inline-c r " = GIN_IM_FROM_BINARY(GIN_IM_TO_BINARY(" a ") >> GIN_IM_TO_INT(" amt "), GIN_IM_TO_INT(" len-a "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary >>> (a amt)
  if (Ginger::immediate? a)
    define len-a (Binary::length a)
    define r false
    inline-c r " = GIN_IM_FROM_BINARY(GIN_IM_TO_BINARY_SIGNED(" a ") >> GIN_IM_TO_INT(" amt "), GIN_IM_TO_INT(" len-a "));"
    r
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit

define Binary->String (a)
  define len (Binary::length a)
  define i len
  define r (String::make i)
  if (Ginger::immediate? a)
    while (> i 0)
      define b false
      inline-c b " = GIN_IM_FROM_CHAR8(((((unsigned long)(GIN_IM_TO_BINARY(" a "))) << (32 - GIN_IM_TO_INT(" i "))) >> 31) + 48);"
      String::nth! r (- len i) b
      -- i
  else:
    ; TODO:
    println "NIM Binaries not supported yet"
    exit
  r

define bin (residual: r)
  ; TODO:
  println "NIM Binaries not supported yet"
  exit

;;;
;;; MATH
;;;

; Functions in this section should work on the entire numeric tower

; define! e          2.7182818284590452353602874713526624977572
; define! one/e      0.3678794411714423215955237701614608674458
; define! e2         7.3890560989306502272304274605750078131803 ; e^2
; define! epi/4      2.1932800507380154565597696592787382234616 ; e^
; define! log2e      1.44269504088896340735992468100189214
; define! log10e     0.434294481903251827651128918916605082
; define! ln2        0.6931471805599453094172321214581765680755
; define! ln3        1.0986122886681096913952452369225257046475
; define! lnpi       1.1447298858494001741434273513530587116473
; define! ln10       2.3025850929940456840179914546843642076011
; define! one/ln2    1.4426950408889634073599246810018921374266
; define! one/ln10   0.4342944819032518276511289189166050822944
; define! pi         3.1415926535897932384626433832795028841972
define pi 3.14159265
; define! pi/2       1.57079632679489661923132169163975144
; define! pi/4       0.785398163397448309615660845819875721
; define! one/pi     0.3183098861837906715377675267450287240689
; define! two/pi     0.636619772367581343075535053490057448
; define! two/sqrtpi 1.12837916709551257389615890312154517
; define! sqrtpi     1.7724538509055160272981674833411451827975
; define! pi2        9.8696044010893586188344909998761511353137 ; pi^2
; define! degree     0.0174532925199432957692369076848861271344
; define! gamma1/2   1.7724538509055160272981674833411451827975
; define! gamma1/3   2.6789385347077476336556929409746776441287
; define! gamma2/3   1.3541179394264004169452880281545137855193
; define! sqrt2      1.4142135623730950488016887242096980785697
; define! sqrt3      1.7320508075688772935274463415058723669428
; define! sqrt5      2.2360679774997896964091736687312762354406
; define! sqrt10     3.1622776601683793319988935444327185337196
; define! cubert2    1.2599210498948731647672106072782283505703
; define! cubert3    1.4422495703074083823216383107801095883919
; define! fourthrt2  1.4422495703074083823216383107801095883919
; define! one/sqrt2  0.707106781186547524400844362104849039
; define! phi        1.6180339887498948482045868343656381177203
; define! lnphi      0.4812118250596034474977589134243684231352
; define! one/lnphi  0.4812118250596034474977589134243684231352
; define! euler      0.5772156649015328606065120900824024310422
; define! eeuler     1.7810724179901979852365041031071795491696 ; e^euler
; define! sin1       0.8414709848078965066525023216302989996226
; define! cos1       0.5403023058681397174009366074429766037323
; define! zeta3      1.2020569031595942853997381615114499907650

define + (a b)
  if (and (Fixnum? a) (Fixnum? b))
    Fixnum::+ a b
  elsif: (and (Integer? a) (Integer? b))
    Integer::+ a b

define - (a b)
  if (and (Fixnum? a) (Fixnum? b))
    Fixnum::- a b
  elsif: (and (Integer? a) (Integer? b))
    Integer::- a b

define * (a b)
  if (and (Fixnum? a) (Fixnum? b))
    Fixnum::* a b
  elsif: (and (Integer? a) (Integer? b))
    Integer::* a b

define / (a b)
  if (and (Fixnum? a) (Fixnum? b))
    Fixnum::/ a b
  elsif: (and (Integer? a) (Integer? b))
    Integer::/ a b

define < (a b)
  if (and (Fixnum? a) (Fixnum? b))
    Fixnum::< a b
  elsif: (and (Integer? a) (Integer? b))
    Integer::< a b

define <= (a b)
  if (and (Fixnum? a) (Fixnum? b))
    Fixnum::<= a b
  elsif: (and (Integer? a) (Integer? b))
    Integer::<= a b

define > (a b)
  if (and (Fixnum? a) (Fixnum? b))
    Fixnum::> a b
  elsif: (and (Integer? a) (Integer? b))
    Integer::> a b

define >= (a b)
  if (and (Fixnum? a) (Fixnum? b))
    Fixnum::>= a b
  elsif: (and (Integer? a) (Integer? b))
    Integer::>= a b

define = (a b)
  if (and (Fixnum? a) (Fixnum? b))
    Fixnum::= a b
  elsif: (and (Integer? a) (Integer? b))
    Integer::= a b

define max (a b)
  if (> a b) a
  else: b

define min (a b)
  if (< a b) a
  else: b

define abs (a)
  inline-c "if (GIN_IM_TO_SIGNED_INT(" a ") >= 0)" result "=" a "; else " result "= GIN_IM_FROM_INT(-1*GIN_IM_TO_SIGNED_INT(" a "));"

define modulo (a b)
  inline-c result "=GIN_IM_FROM_INT(GIN_IM_TO_SIGNED_INT(" a ") % GIN_IM_TO_SIGNED_INT(" b "));"

define zero? (a)
  inline-c result "=GIN_IM_FROM_BOOL(GIN_IM_TO_SIGNED_INT(" a ") == 0);"

define positive? (a)
  inline-c result "=GIN_IM_FROM_BOOL(GIN_IM_TO_SIGNED_INT(" a ") >= 0);"

define negative? (a)
  inline-c result "=GIN_IM_FROM_BOOL(GIN_IM_TO_SIGNED_INT(" a ") < 0);"

define odd? (a)
  inline-c result "=GIN_IM_FROM_BOOL((GIN_IM_TO_SIGNED_INT(" a ") % 2) == 1);"

define even? (a)
  inline-c result "=GIN_IM_FROM_BOOL((GIN_IM_TO_SIGNED_INT(" a ") % 2) == 0);"

define remainder (a b)
  modulo a b
  
define gcd (a b)
  if (= b 0)
    a
  else:
    gcd b (remainder a b)

define Number? (a)
  or (Integer? a) (Flonum? a)

define nocall (a)
  inline-c result " = " a ";"

; TODO
; quotient  
; lcm
; numerator
; denominator
; floor
; ceiling
; truncate
; round
; rationalize
; exp
; log

define degree->radian (d)
  * d (/ pi 180)

define sin (t)
  ;   inline-c "GIN_NEW_FLONUM(" result ", sin(GIN_NIM_GET_FLONUM(" t ")));"
  noop

define cos (t)
  ;  inline-c "GIN_NEW_FLONUM(" result ", cos(GIN_NIM_GET_FLONUM(" t ")));"
  noop 

; tan
; asin
; acos
; atan
; sqrt

define expt (a b)
  if (and (Integer? a) (Integer? b))
    set a (Integer->Flonum a)
    set b (Integer->Flonum b)

    inline-c result "= GIN_IM_FROM_INT((int)pow(GIN_NIM_GET_FLONUM(" a "), GIN_NIM_GET_FLONUM(" b ")));"
  else:
    if (Integer? a)
      set a (Integer->Flonum a)
    if (Integer? b)
      set b (Integer->Flonum b)
    inline-c "GIN_NEW_FLONUM(" result ", pow(GIN_NIM_GET_FLONUM(" a "), GIN_NIM_GET_FLONUM(" b ")));"

; make-rectangular
; make-polar
; real-part
; imag-part
; magnitude
; angle
; number->string
; string->number

;;;
;;; Fixnum
;;;

define Fixnum::make (residual: r)
  if (Null? r)
    inline-c "GIN_NEW_FIXNUM(" result ", 0)" 
  else:
    define t (first r)
    inline-c "GIN_NEW_FIXNUM(" result ", GIN_IM_TO_SIGNED_INT(" t "))"

define Fixnum? (a)
  if (Ginger::immediate? a)
    inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_IM_INT(" a "));"
  else:
    false

define Fixnum->Binary (a)
  inline-c result "= GIN_IM_FROM_BINARY(GIN_IM_TO_SIGNED_INT(" a "),20);"

define! Fixnum->String (a)
  inline-c result " = fmt_long(GIN_IM_TO_SIGNED_INT(" a "));"

define! Fixnum->Flonum (a)
  inline-c "GIN_NEW_FLONUM(" result ", (double)GIN_IM_TO_SIGNED_INT(" a "));"

define! Fixnum->Char (a)
  inline-c result "= GIN_IM_FROM_CHAR8((char)(GIN_IM_TO_SIGNED_INT(" a ")));"

define! Fixnum + (a b)
  inline-c result " = GIN_IM_FROM_INT(GIN_IM_TO_SIGNED_INT(" a ") + GIN_IM_TO_SIGNED_INT(" b "));"

define! Fixnum - (a b)
  inline-c result " = GIN_IM_FROM_INT(GIN_IM_TO_SIGNED_INT(" a ") - GIN_IM_TO_SIGNED_INT(" b "));"

define! Fixnum / (a b)
  inline-c result " = GIN_IM_FROM_INT(GIN_IM_TO_SIGNED_INT(" a ") / GIN_IM_TO_SIGNED_INT(" b "));"

define! Fixnum * (a b)
  inline-c result " = GIN_IM_FROM_INT(GIN_IM_TO_SIGNED_INT(" a ") * GIN_IM_TO_SIGNED_INT(" b "));"

define! Fixnum < (a b)
  inline-c result " = GIN_IM_FROM_BOOL(GIN_IM_TO_SIGNED_INT(" a ") < GIN_IM_TO_SIGNED_INT(" b "));"

define! Fixnum > (a b)
  inline-c result " = GIN_IM_FROM_BOOL(GIN_IM_TO_SIGNED_INT(" a ") > GIN_IM_TO_SIGNED_INT(" b "));"

define! Fixnum >= (a b)
  inline-c result " = GIN_IM_FROM_BOOL(GIN_IM_TO_SIGNED_INT(" a ") >= GIN_IM_TO_SIGNED_INT(" b "));"

define! Fixnum <= (a b)
  inline-c result " = GIN_IM_FROM_BOOL(GIN_IM_TO_SIGNED_INT(" a ") <= GIN_IM_TO_SIGNED_INT(" b "));"

define! Fixnum = (a b)
  inline-c result " = GIN_IM_FROM_BOOL(GIN_IM_TO_SIGNED_INT(" a ") == GIN_IM_TO_SIGNED_INT(" b "));"

;;; INTEGERS
;;;

define Integer? (a)
  if (Fixnum? a)
    true
  else:
    if (Type::eq? (type a) Integer)
      true
    else:
      false

define Integer->Binary (a)
  if (Fixnum? a)
    Fixnum->Binary a
  else:
    ; TODO
    println "Bignums not supported yet"
    exit

define Integer->String (a)
  if (Fixnum? a)
    Fixnum->String a
  else:
    ; TODO
    println "Bignums not supported yet"
    exit

define Integer->Flonum (a)
  if (Fixnum? a)
    Fixnum->Flonum a
  else:
    ; TODO
    println "Bignums not supported yet"
    exit

define Integer->Char (a)
  Fixnum->Char a

define! Integer + (a b)
  ; TODO - take care of overflow
  define r (Binary::+ (Integer->Binary a) (Integer->Binary b))
  Binary->Integer r

define! Integer - (a b)
  ; TODO - take care of overflow
  define r (Binary::- (Integer->Binary a) (Integer->Binary b))
  Binary->Integer r

define! Integer * (a b)
  ; TODO - take care of overflow
  define r (Binary::* (Integer->Binary a) (Integer->Binary b))
  Binary->Integer r

define! Integer / (a b)
  ; TODO - take care of overflow
  define r (Binary::/ (Integer->Binary a) (Integer->Binary b))
  Binary->Integer r

define Integer < (a b)
  Binary::< (Integer->Binary a) (Integer->Binary b)

define Integer <= (a b)
  Binary::<= (Integer->Binary a) (Integer->Binary b)

define Integer > (a b)
  Binary::> (Integer->Binary a) (Integer->Binary b)

define Integer >= (a b)
  Binary::>= (Integer->Binary a) (Integer->Binary b)

define Integer = (a b)
  Binary::eq? (Integer->Binary a) (Integer->Binary b)
    
;;; FLONUMS
;;;

define Flonum? (a)
  if (Type::eq? (type a) Flonum) true
  else: false

define Flonum->Binary (a)
  println "Flonum->Binary not implemented"
  exit
;  inline-c result "= GIN_IM_FROM_INT((int)GIN_NIM_GET_FLONUM(" a "));"

define! Flonum->String (a)
  inline-c result " = fmt_double(GIN_NIM_GET_FLONUM(" a "));"

define Flonum->Integer (a)
  ; TODO - check for overflow
  inline-c result "= GIN_IM_FROM_INT((int)GIN_NIM_GET_FLONUM(" a "));"

define! Flonum + (a b)
  inline-c "GIN_NIM_SET_FLONUM(" result ", GIN_NIM_GET_FLONUM(" a ") + GIN_NIM_GET_FLONUM(" b "));"

define! Flonum - (a b)
  inline-c "GIN_NIM_SET_FLONUM(" result ", GIN_NIM_GET_FLONUM(" a ") + GIN_NIM_GET_FLONUM(" b "));"

define! Flonum / (a b)
  inline-c "GIN_NIM_SET_FLONUM(" result ", GIN_NIM_GET_FLONUM(" a ") / GIN_NIM_GET_FLONUM(" b "));"

define! Flonum * (a b)
  inline-c "GIN_NIM_SET_FLONUM(" result ", GIN_NIM_GET_FLONUM(" a ") * GIN_NIM_GET_FLONUM(" b "));"

;;;
;;; BOOLEANS
;;;

define Boolean? (a)
  inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_BOOL(" a "));"

define Boolean->Binary (a)
  inline-c result "= GIN_IM_FROM_BINARY(GIN_IM_TO_BOOL(" a "),22);"

define Boolean->String (a)
  if (true? a)
    "true"
  else:
    "false"

define not (a)
  inline-c result " = GIN_IM_FROM_BOOL(GIN_IS_FALSE(" a "));"

define true? (a)
  inline-c result " = GIN_IM_FROM_BOOL(GIN_IS_TRUE(" a "));"

define false? (a)
  inline-c result " = GIN_IM_FROM_BOOL(GIN_IS_FALSE(" a "));"

;;;
;;; PAIRS and LISTS
;;;

define Cons? (a)
  or (Type::eq? (type a) Cons) (Type::eq? (type a) Bcons)

define bcons? (a)
  Type::eq? (type a) Bcons

define Null? (a)
  inline-c result " = GIN_IM_FROM_BOOL(GIN_IS_NULL(" a "));"

define empty? (a)
  ; TODO - empty is not really the sama as null
  Null? a

define list? (a)
  if (Cons? a)
    if (Null? (second* a)) true
    else: (list? (second* a))
  else:
    false

define pair (a b)
  inline-c "GIN_NEW_PAIR(" result "," a "," b ");" 

define cons (a b c)
  inline-c "GIN_NEW_CONS(" result "," a "," b "," c ");" 

define bcons (a b c)
  define t (Type::index Bcons)
  inline-c "GIN_NEW_CONS(" result "," a "," b "," c ");" 
  inline-c "GIN_NIM_GET_TYPE(" result ") = " t ";"

define first (a)
  inline-c result "= GIN_NIM_GET_F0(" a ");"

define properties (a)
  inline-c result "= GIN_NIM_GET_F1(" a ");"

define second* (a)
  if (Cons? a)
    inline-c result "= GIN_NIM_GET_F2(" a ");"
  else:
    println "Bad argument to second*"
    println a
    exit

define first! (p a)
  inline-c "GIN_NIM_SET_F0(" p "," a ");"

define properties! (p a)
  inline-c "GIN_NIM_SET_F1(" p "," a ");"

define second*! (p a)
  inline-c "GIN_NIM_SET_F2(" p "," a ");"

; These functions return the value of the element at the position in the list.
define nth (a i)
  repeat (- i 1)
    set a (second* a)
  first a

define second (a)
  nth a 2

define third (a)
  nth a 3

define fourth (a)
  nth a 4

define fifth (a)
  nth a 5

define sixth (a)
  nth a 6

define seventh (a)
  nth a 7

define eigth (a)
  nth a 8

define ninth (a)
  nth a 9

; These functions (with the post fix *) return the cell at the position in the list.
define nth* (a i)
  repeat (- i 1)
    set a (second* a)
  a

define third* (a)
  nth* a 3

define fourth* (a)
  nth* a 4

define fifth* (a)
  nth* a 5

define sixth* (a)
  nth* a 6

define seventh* (a)
  nth* a 7

define eigth* (a)
  nth* a 8

define ninth* (a)
  nth* a 9

define last (a)
  while (Cons? (second* a))
    set a (second* a)
  first a

define last* (a)
  while (Cons? (second* a))
    set a (second* a)
  a

define length (a)
  define len 0
  while (Cons? a)
    set a (second* a)
    ++ len
  len

define append (a b)
  ; TODO - currently destructive. fix it.
  ; TODO - should be residual?
  if (Null? a)
    b
  else:
    define t (last* a)
    second*! t b
    a

define reverse (a)
  ; TODO - provide built in faster implementation!
  if (Null? a)
    a
  else:
    append (reverse (second* a)) (list (first a))

define list (residual: r)
  r

define contains? (lst a)
  if (Null? lst) false
  elsif: (eq? (first lst) a) true
  else: (contains? (second* lst) a)

define split-list (lst v)
  define a null
  define b null
  define middle false
  each l lst
    if (eq? l v)
      set middle true
    else:
      if (eq? middle false)
        set a (append a (list l))
      else:
        set b (append b (list l))
  pair a b

define List::duplicate (lst)
  if (Null? lst) null
  else:
    pair (first lst) (List::duplicate (second* lst))

;;; CHARACTERS
;;;

define Char? (a)
  if (Ginger::immediate? a)
    inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_CHAR8(" a "));"
  else:
    false

define Char->Binary (a)
  inline-c result "= GIN_IM_FROM_BINARY(GIN_IM_TO_CHAR8(" a "),22);"

define Char->String (a)
  String::string a

define Char->Integer (a)
  inline-c result "= GIN_IM_FROM_INT((long)(GIN_IM_TO_CHAR8(" a ")));"

define Char eq? (a b)
  inline-c result "= GIN_IM_FROM_BOOL(GIN_IM_TO_CHAR8(" a ") == GIN_IM_TO_CHAR8(" b "));"

define Char alphabetic? (a)
  inline-c result "= GIN_IM_FROM_BOOL(isalpha(GIN_IM_TO_CHAR8(" a ")));"

define Char numeric? (a)
  inline-c result "= GIN_IM_FROM_BOOL(isdigit(GIN_IM_TO_CHAR8(" a ")));"

define Char whitespace? (a)
  inline-c result "= GIN_IM_FROM_BOOL(isspace(GIN_IM_TO_CHAR8(" a ")));"

define Char upper-case? (a)
  ; TODO
  println "upper-case? is not implemented"
  exit

define Char lower-case? (a)
  ; TODO
  println "lower-case? is not implemented"
  exit

define Char upcase (a)
  ; TODO
  println "upcase is not implemented"
  exit

define Char downcase (a)
  ; TODO
  println "downcase is not implemented"
  exit


;;; SYMBOLS
;;;

define Symbol? (a)
  if (Ginger::immediate? a)
    inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_IM_SYM(" a "));"
  else:
    false

define Symbol->Binary (a)
  inline-c result "= GIN_IM_FROM_BINARY(GIN_IM_TO_SYM(" a "),22);"

define Symbol->String (a)
  Ginger::Symbol->String a

define Symbol eq? (a b)
  inline-c result "= GIN_IM_FROM_BOOL(" a "==" b ");"

;;;
;;; LABELS
;;;


define Label? (v)
  inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_LABEL(" v "));"

define Label eq? (a b)
  inline-c result "= GIN_IM_FROM_BOOL(" a "==" b ");"

define Label->String (a)
  define b false
  inline-c b "= GIN_IM_FROM_SYM(GIN_IM_TO_LABEL(" a "));"
  Symbol->String b

define Ginger::String->Label (a)
  define b (Ginger::String->Symbol a)
  inline-c result "= GIN_IM_FROM_LABEL(GIN_IM_TO_SYM(" b "));"

;;;
;;; STRINGS
;;;

define String make (size)
  define t null
  inline-c "GIN_NEW_EMPTY_STR8(" t ");"
  inline-c "GIN_ALLOCATE(GIN_STR_VALUE(" t "),char*,sizeof(char)*(GIN_IM_TO_INT(" size ")+1));"
  inline-c "GIN_STR_LENGTH(" t ") = GIN_IM_TO_INT(" size ");"
  t

define String string (residual: r)
  define t null
  inline-c "GIN_NEW_EMPTY_STR8(" t ");"
  define size (length r)
  define j 0
  inline-c "GIN_ALLOCATE(GIN_STR_VALUE(" t "),char*,sizeof(char)*(GIN_IM_TO_INT(" size ")+1));"
  inline-c "GIN_STR_LENGTH(" t ") = GIN_IM_TO_INT(" size ");"
  each i r
    inline-c "GIN_STR_VALUE(" t ")[GIN_IM_TO_INT(" j ")] = (char)GIN_IM_TO_CHAR8(" i ");"
    ++ j
  inline-c "GIN_STR_VALUE(" t ")[GIN_IM_TO_INT(" size ")] = 0;"
  t

define String join (string-list (delimiter " ") (grammar 'infix))
  ; delimiter defaults to a single space " "
  ; ignore grammar: default to SRFI 13 infix behavior
  ; TODO - Add grammar options
  define z ""
  define len (length string-list)
  define loop-count 0
  while (< loop-count (- len 1))
    define str (nth string-list (+ loop-count 1))
    set z (String::append z str delimiter)
    ++ loop-count
  if (< loop-count len)
    set z (String::append z (last string-list))
  z

define String? (a)
  inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_STR8(" a "));"

define String->Binary (a)
  ; TODO
  println "String->Binary not implemented"
  exit

define String length (a)
  inline-c result "= GIN_IM_FROM_INT(GIN_STR_LENGTH(" a "));"

define String nth (a k)
  inline-c result "= GIN_IM_FROM_CHAR8(GIN_STR_VALUE(" a ")[GIN_IM_TO_INT(" k ")]);"

define String first (a)
  String::nth a 0

define String last (a)
  String::nth a (- (String::length a) 1)

define String nth! (a k c)
  inline-c "GIN_STR_VALUE(" a ")[GIN_IM_TO_INT(" k ")] = GIN_IM_TO_CHAR8(" c ");"

define String eq? (a b)
  if (= (String::length a) (String::length b))
    inline-c result "= GIN_IM_FROM_BOOL(strncmp(GIN_STR_VALUE(" a "), GIN_STR_VALUE(" b "), GIN_STR_LENGTH(" a ")) == 0);"
  else:
    false

define String compare (a b (with-locale false) (with-case true))
  ; TODO
  println "String::compare not implemented."
  exit

define String substring (a i j)
  ; where:
  ;  a = the string
  ;  i = the start position
  ;  j = the number of characters to get (including i)
  define t false
  define total-length (- j i)
  inline-c "GIN_NEW_EMPTY_STR8(" result ");"
  inline-c "GIN_ALLOCATE(GIN_STR_VALUE(" result "), char*, sizeof(char)*(GIN_IM_TO_INT(" total-length ") + 1));"
  inline-c "strncpy(&(GIN_STR_VALUE(" result ")[0]),&(GIN_STR_VALUE(" a ")[GIN_IM_TO_INT(" i ")]),GIN_IM_TO_INT(" total-length "));"
  inline-c "GIN_STR_VALUE(" result ")[GIN_IM_TO_INT(" total-length ")] = 0;"
  inline-c "GIN_STR_LENGTH(" result ") = GIN_IM_TO_INT(" total-length ");"
  
define String append (residual: r)
  define total-length 0
  define z false
  each i r
    set total-length (+ (String::length i) total-length)
  inline-c "GIN_NEW_EMPTY_STR8(" z ");"
  inline-c "GIN_ALLOCATE(GIN_STR_VALUE(" z "),char*,sizeof(char)*(GIN_IM_TO_INT(" total-length ")+1));"
  inline-c "GIN_STR_LENGTH(" z ") = GIN_IM_TO_INT(" total-length ");"
  define j 0
  each i r
    inline-c "strncpy(&(GIN_STR_VALUE(" z ")[GIN_IM_TO_INT(" j ")]),GIN_STR_VALUE(" i "),GIN_STR_LENGTH(" i "));"
    set j (+ j (String::length i))
  inline-c "GIN_STR_VALUE(" z ")[GIN_IM_TO_INT(" total-length ")] = 0;"
  z

define String::put-string (s)
  println "String::put-string"
  define len (String::length s)
  define i 0
  while (< i len)
    inline-c "printf(\"%c\", GIN_STR_VALUE(" s ")[GIN_IM_TO_INT(" i ")]);"
    ++ i
  println len i
  println ""

define String replace (target replacement)
  define len (String::length target)
  println "String::replace - Not implemented yet!"

define String split (str ch)
  define len (String::length str)
  define split (a b)
    if (>= b len)
      if (= a b) (list "")
      else: (pair (String::substring str a b) null)
    elsif: (Char::eq? ch (String::nth str b))
      if (= a b)
        pair "" (split (+ 1 a) (+ 1 b))
      else:
        pair (String::substring str a b) (split (+ 1 b) (+ 1 b))
    else:
      split a (+ 1 b)
  split 0 0

; Path functions
define base-name (str)
  define comp (String::split str ._)
  define base-file-name (String::join (reverse (second* (reverse comp))) ".")
  base-file-name


;;; Vectors
;;;
;;; Ginger vectors, unlike Scheme's, are dynamic arrays.

; TODO: define! Vector make ((size -1) residual: r)
define Vector make (residual: r)
  define size (length r)
  define tmp 0
  define j 0
  inline-c "GIN_ALLOCATE(" tmp ", GIN_OBJ, sizeof(GingerVector));"
  inline-c "((GingerVector*)(" tmp "))->type_index = GIN_TYPE_VECTOR;"
  inline-c "((GingerVector*)(" tmp "))->length = GIN_IM_TO_INT(" size ");"
  inline-c "((GingerVector*)(" tmp "))->pool_length = GIN_IM_TO_INT(" size ");"
  if (> size 0)
    inline-c "GIN_ALLOCATE(((GingerVector*)(" tmp "))->value, GIN_OBJ*, sizeof(GIN_OBJ)*(GIN_IM_TO_INT(" size ")));"
    each i r
      inline-c "((GingerVector*)(" tmp "))->value[GIN_IM_TO_INT(" j ")] = " i ";"
      ++ j
  else:
    inline-c "((GingerVector*)(" tmp "))->value = 0;"
  tmp

define Vector push (self a)
  define tmp false
  inline-c "if (((GingerVector*)(" self "))->length >= ((GingerVector*)(" self "))->pool_length) {"
  inline-c "GIN_ALLOCATE(" tmp ", GIN_OBJ, sizeof(GIN_OBJ)*(((GingerVector*)(" self "))->length * 2 + 1));"
  inline-c "if (((GingerVector*)(" self "))->length > 0) memcpy(" tmp ", ((GingerVector*)(" self "))->value, sizeof(GIN_OBJ)*(((GingerVector*)(" self "))->length));"
  inline-c "((GingerVector*)(" self "))->value = (GIN_OBJ*)(" tmp ");"
  inline-c "((GingerVector*)(" self "))->pool_length = (((GingerVector*)(" self "))->length * 2 + 1);"
  inline-c "}"
  inline-c "((GingerVector*)(" self "))->value[((GingerVector*)(" self "))->length] = " a ";"
  inline-c "((GingerVector*)(" self "))->length++;"

define Vector? (self)
  Type::eq? (type self) Vector

define Vector get (self index)
  inline-c result " = ((GingerVector*)(" self "))->value[GIN_IM_TO_INT(" index ")];"

define Vector set (self index value)
  inline-c "((GingerVector*)(" self "))->value[GIN_IM_TO_INT(" index ")] = " value ";"
  true

define Vector length (self)
  inline-c result " = GIN_IM_FROM_INT(((GingerVector*)(" self "))->length);"

define Vector->list (self)
  println "Vector->list is not implemented."
  exit

define Vector fill (self value)
  println "Vector::fill is not implemented."
  exit

define Vector->String (a)
  ; TODO - this should use Vector->list (but Vector->list isn't implemented)
  ;   this also needs all the other to-str functions because a vector can
  ;   hold anything
  "*vector*"

define Vector first (self)
  inline-c result " = ((GingerVector*)(" self "))->value[0];"

define Vector last (self)
  inline-c result " = ((GingerVector*)(" self "))->value[((GingerVector*)(" self "))->length-1];"

define Vector pop (self)
  inline-c "((GingerVector*)(" self "))->length--;"

;;; DICTS
;;;

define Dict make (residual: d)
  define dict 0
  inline-c "GIN_ALLOCATE(" dict ", void*, sizeof(GingerDictionary));"
  inline-c "GIN_NIM_GET_TYPE(" dict ") = GIN_TYPE_DICT;"
  ; arguments should be [key1 value1 ... keyN valueN]
  define len (length d)
  if (not (= (modulo len 2) 0))
    println "dict: not provided with an even number of key-value pairs"
    exit
  
  define loop-count 0
  while (< loop-count len)
    define key (nth d (+ loop-count 1))
    define value (nth d (+ loop-count 2))
    Dict::set dict key value
    set loop-count (+ loop-count 2)

  dict

define Dict->String (a)
  define b false
  inline-c b " = fmt_ulong((unsigned long)" a ");"
  String::append "#[Dict " b "]"

define Dict? (self)
  Type::eq? (type self) Dict

define Dict->keys (self)
  inline-c result " = gin_dict_keys(" self ", 1);"

define Dict set (self key value)
  define i (pair key value)
  inline-c "gin_dict_insert(" self ", " i ");"

define Dict get (self key)
  define r 0
  inline-c r "= gin_dict_contains(" self ", " key ");"
  if (Cons? r)
    second* r
  else:
    false

define Dict contains? (self key)
  define r 0
  inline-c r "= gin_dict_contains(" self ", " key ");"
  if (Cons? r)
    true
  else:
    false

define Dict remove (d key)
  ; TODO
  println "Dict::remove not implemented."
  exit

define Dict clear (d)
  ; TODO
  println "Dict::clear not implemented."
  exit
  
define Dict size (d)
  ; TODO
  println "Dict::size not implemented."
  exit

;;; FUNCTIONS
;;;

define Function? (self)
  Type::eq? (type self) Function

define Function->String (a)
  ; TODO - print function name
  "#[Function ***]"

;;; MISC
;;;

define Null->Binary (a)
  0

define Foreign->String (a)
  define b false
  inline-c b " = fmt_ulong((unsigned long)" a ");"
  inline-c "gc_analyze(mm, " a ");"
  String::append "#[Foreign " b "]"

;;; STREAMS
;;;

; Scheme R5RS style ports (only in Ginger they're streams)

define current-input-stream 0
define current-output-stream 0

define input-stream (inline-c result "= GIN_IM_FROM_INT(GIN_INPUT_STREAM_MODE);")
define output-stream (inline-c result "= GIN_IM_FROM_INT(GIN_OUTPUT_STREAM_MODE);")

define input-stream? (obj)
  inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_INPUT_STREAM(" obj "));"

define output-stream? (obj)
  inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_OUTPUT_STREAM(" obj "));"

define open-file (filename mode)
  ; This function is not in R5RS
  if (eq? mode input-stream)
    inline-c "GIN_NEW_STREAM(" result ", fopen(GIN_STR_VALUE(" filename "), \"r\"), 1);"
  else:
    inline-c "GIN_NEW_STREAM(" result ", fopen(GIN_STR_VALUE(" filename "), \"w\"), 0);"

define open-input-file (filename)
  set current-input-stream (open-file filename input-stream)

define open-output-file (filename)
  ; R5RS: If a file with the given name already exists, the effect is unspecified.
  ; In our case an existing file is truncated to zero length.
  set current-output-stream (open-file filename output-stream)

define close-stream (stream)
  ; This function is not in R5RS
  ; C doesn't really make a distinction between 
  ; read/write when closing a file but R5RS does.
  ; Ignore close on string streams.
  ; TODO - fclose returns an integer (ignore it?)
  inline-c "if (GIN_IS_STREAM(" stream ")) fclose(GIN_NIM_GET_STREAM(" stream  "));"

define close-input-stream (stream)
  close-stream stream

define close-output-stream (stream)
  close-stream stream

define get-char ((stream current-input-stream))
  inline-c " \
    if (GIN_IS_STREAM(" stream ")) \
      " result "= GIN_IM_FROM_CHAR8(fgetc(GIN_NIM_GET_STREAM(" stream "))); \
    else if (GIN_IS_STRING_STREAM(" stream ")) { \
      if (GIN_NIM_GET_STRING_STREAM_LENGTH(" stream ") == GIN_NIM_GET_STRING_STREAM_POSITION(" stream ")) { \
        " result "= GIN_IM_FROM_CHAR8(EOF); \
      } else { \
        " result "= GIN_IM_FROM_CHAR8(GIN_STR_VALUE(" stream ")[GIN_NIM_GET_STRING_STREAM_POSITION(" stream ")]); \
        GIN_NIM_SET_STRING_STREAM_POSITION(" stream ",((long)GIN_NIM_GET_STRING_STREAM_POSITION(" stream ")+1)); \
      } \
    }"

define peek-char ((stream current-input-stream))
  define c 0
  inline-c " \
    if (GIN_IS_STREAM(" stream ")) { \
      " c "= GIN_IM_FROM_CHAR8(fgetc(GIN_NIM_GET_STREAM(" stream "))); \
      " result "= GIN_IM_FROM_CHAR8(ungetc( \
      GIN_IM_TO_CHAR8(" c "), \
      GIN_NIM_GET_STREAM(" stream "))); \
    } \
    else if (GIN_IS_STRING_STREAM(" stream ")) { \
      if (GIN_NIM_GET_STRING_STREAM_LENGTH(" stream ") == GIN_NIM_GET_STRING_STREAM_POSITION(" stream ")) { \
        " result "= GIN_IM_FROM_CHAR8(EOF); \
      } else \
        " result "= GIN_IM_FROM_CHAR8(GIN_STR_VALUE(" stream ")[GIN_NIM_GET_STRING_STREAM_POSITION(" stream ")]); \
    }"

define unget-char (stream c)
  inline-c " \
    if (GIN_IS_STREAM(" stream ")) { \
      " result "= GIN_IM_FROM_CHAR8(ungetc( \
      GIN_IM_TO_CHAR8(" c "), \
      GIN_NIM_GET_STREAM(" stream "))); \
    } else if (GIN_IS_STRING_STREAM(" stream ")) { \
      GIN_NIM_SET_STRING_STREAM_POSITION(" stream ",((long)GIN_NIM_GET_STRING_STREAM_POSITION(" stream ")-1)); \
      GIN_STR_VALUE(" stream ")[GIN_NIM_GET_STRING_STREAM_POSITION(" stream ")] = GIN_IM_TO_CHAR8(" c "); \
      " result "= GIN_IM_FROM_CHAR8(GIN_STR_VALUE(" stream ")[GIN_NIM_GET_STRING_STREAM_POSITION(" stream ")]); \
    } "

define eof-object? (obj)
  inline-c result "= GIN_IM_FROM_BOOL(" obj " == GIN_IM_FROM_CHAR8(EOF));"

define char-ready? (stream)
  println "char-ready? is not implemented."
  exit

define newline ((stream current-output-stream))
  write-char stream newline_

define write-char (stream char)
  ; TODO - fputc returns integer (ignore it?)
  ; TODO - if this function isn't working correctly it's because 
  ;  compiling with -Wall was warning about not having parentheses
  ;  around shifts with + or -. I put a bunch of parens around the
  ;  shifts to shut the compiler up. They are likely wrong...
  ;  (We need more test coverage)
  inline-c " \
    if (GIN_IS_STREAM(" stream ")) \
      fputc(GIN_IM_TO_CHAR8(" char "), GIN_NIM_GET_STREAM(" stream ")); \
    if (GIN_IS_STRING_STREAM(" stream ")) { \
      GIN_NEW_EMPTY_STRING_STREAM(" result ", GIN_OUTPUT_STREAM_MODE); \
      GIN_STR_VALUE(" result ") = GIN_STR_VALUE(" stream "); \
      GIN_ALLOCATE(GIN_STR_VALUE(" stream "),char*,sizeof(char)*(((GIN_NIM_GET_STRING_STREAM_LENGTH(" stream ")) + 1))); \
      strncpy(&(GIN_STR_VALUE(" stream ")[0]),GIN_STR_VALUE(" result "),GIN_NIM_GET_STRING_STREAM_LENGTH(" stream ")); \
      GIN_NIM_SET_STRING_STREAM_LENGTH(" stream ", ((GIN_NIM_GET_STRING_STREAM_LENGTH(" stream ")) + 1)); \
      GIN_STR_VALUE(" stream ")[GIN_NIM_GET_STRING_STREAM_LENGTH(" stream ")-1] = (char)GIN_IM_TO_CHAR8(" char "); \
      GIN_NIM_SET_STRING_STREAM_POSITION(" stream ",((long)GIN_NIM_GET_STRING_STREAM_POSITION(" stream ")+1)); \
    }"

; Seek & Tell for random-acess streams
define SEEK-SET 0
define SEEK-CUR 1
define SEEK-END 2
define stream-seek (stream offset whence)
  ; whence one of SEEK_SET (offset from start [only positive numbers make sense])
  ; SEEK_CUR (offset from current position [+/- distance from position])
  ; SEEK_END (offset from end [only negative numbers make sense])
  ; TODO - fseek returns an integer (ignore it?)
  inline-c " \
    if (GIN_IS_STREAM(" stream ")) \
      fseek(GIN_NIM_GET_STREAM(" stream "), \
        GIN_IM_TO_INT(" offset "), \
        GIN_IM_TO_INT(" whence ") \
        ); \
    if (GIN_IS_STRING_STREAM(" stream ")) { \
      if (GIN_IM_TO_INT(" whence ") == SEEK_SET) GIN_NIM_SET_STRING_STREAM_POSITION(" stream ", GIN_IM_TO_INT(" offset ")); \
      if (GIN_IM_TO_INT(" whence ") == SEEK_CUR) \
        GIN_NIM_SET_STRING_STREAM_POSITION(" stream ", \
          ((long)GIN_NIM_GET_STRING_STREAM_POSITION(" stream ")+GIN_IM_TO_INT(" offset "))); \
      if (GIN_IM_TO_INT(" whence ") == SEEK_END) \
        GIN_NIM_SET_STRING_STREAM_POSITION(" stream ", \
          ((long)GIN_NIM_GET_STRING_STREAM_LENGTH(" stream ")+GIN_IM_TO_INT(" offset "))); \
    }"

define stream-tell (stream)
  inline-c " \
   if (GIN_IS_STREAM(" stream ")) \
     " result "= GIN_IM_FROM_INT(ftell(GIN_NIM_GET_STREAM(" stream "))); \
   if (GIN_IS_STRING_STREAM(" stream ")) \
     " result "= GIN_IM_FROM_INT(GIN_NIM_GET_STRING_STREAM_POSITION(" stream "));"

;;; Streams (see SRFI 6)
;;;

define Stream? (a)
  inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_STREAM(" a "));"

define String-Stream? (a)
  inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_STRING_STREAM(" a "));"

define Generic-Stream? (a)
  or (Stream? a) (String-Stream? a)

define Stream->String (a)
  define b false
  inline-c b " = fmt_ulong((unsigned long)" a ");"
  String::append "#[Stream " b "]"

define String-Stream->String (a)
  define b false
  inline-c b " = fmt_ulong((unsigned long)" a ");"
  String::append "#[String-Stream " b "]"

define open-input-string (str)
  ; Takes a string and returns an input port
  ; delivers characters from the string.
  inline-c "GIN_NEW_STRING_STREAM(" result ", GIN_STR_VALUE(" str "), GIN_INPUT_STREAM_MODE);"
  ;set-string-stream-position 0
  ;set-string-stream-mode 0

define open-output-string ()
  ; Returns an output port that will accumulate
  ; characters for retrieval by get-output-string.
  inline-c "GIN_NEW_EMPTY_STRING_STREAM(" result ", GIN_OUTPUT_STREAM_MODE);"
  ;set-string-stream-position 0
  ;set-string-stream-mode 0

define get-output-string (out-stream)
  ; Given an output port created by open-output-string,
  ; returns a string consisting of the characters that 
  ; have been output to the port so far.
  inline-c "GIN_NEW_STR8(" result ", GIN_STR_VALUE(" out-stream "));"

define string-output-stream? (stream)
  inline-c result "= GIN_IM_FROM_BOOL(GIN_IS_OUTPUT_STREAM(" stream ")&&GIN_IS_STRING_STREAM(" stream "));"

define write-string-stream (out in)
  define out-length 0
  define in-length 0
  define total-length 0
  define tmp false
  inline-c out-length "= GIN_IM_FROM_INT(GIN_NIM_GET_STRING_STREAM_LENGTH(" out "));"
  inline-c in-length "= GIN_IM_FROM_INT(GIN_STR_LENGTH(" in "));"
  set total-length (+ out-length in-length)
  inline-c "GIN_NEW_STR8(" tmp ",GIN_STR_VALUE(" out "));"
  inline-c "GIN_ALLOCATE(GIN_STR_VALUE(" out "),char*,sizeof(char)*((int)GIN_IM_TO_INT(" total-length ")+1));"
  inline-c "strncpy(&(GIN_STR_VALUE(" out ")[0]),GIN_STR_VALUE(" tmp "),GIN_STR_LENGTH(" tmp "));"
  inline-c "strncpy(&(GIN_STR_VALUE(" out ")[GIN_NIM_GET_STRING_STREAM_POSITION(" out ")]), \
    GIN_STR_VALUE(" in "), \
    GIN_STR_LENGTH(" in "));"
  inline-c "GIN_NIM_SET_STRING_STREAM_LENGTH(" out ",GIN_IM_TO_INT(" total-length "));"
  inline-c "GIN_NIM_SET_STRING_STREAM_POSITION(" out ",GIN_IM_TO_INT(" total-length "));"
  inline-c "GIN_STR_VALUE(" out ")[(int)GIN_IM_TO_INT(" total-length ")] = 0;"

; Environment
define getenv (name (default ""))
  inline-c result "= gin_getenv(" name ", " default ");"

define file-exists? (filename)
  inline-c result "= gin_file_exists(" filename ");"

define execute (command)
  inline-c result "= GIN_IM_FROM_INT(system(GIN_STR_VALUE(" command ")));"

; Debug
; Takes a boolean to turn the trace debug on or off and
; takes an intereger to control the maximum trace depth
; use -1 for no maximum.
define gin-debug ((a true) (max-depth -1))
  inline-c "gin_debug = GIN_IM_TO_BOOL(" a ");"
  inline-c "gin_debug_max_depth = GIN_IM_TO_INT(" max-depth ");"
  inline-c "debug_depth = 0;"

; todo - make this an intrinsic and optimize it for each.
define range (i j)
   if (= i j) 
     null
   else:
     if (> i j)
       pair i (range (- i 1) j)
     else:
       pair i (range (+ i 1) j)

; print-term, print and println are for human readable output
define print-term (residual: z)
  define output false
  define term false

  if (and (= (length z) 2) (Generic-Stream? (first z)))
    set output (first z)
    set term (second z)
  elsif: (= (length z) 1)
    set term (first z)
  else:
    println "Invalid number of terms to display."
    exit

  define print-primitive (term)
    if (false? output)
      inline-c "fprintf(stdout,\"%s\", GIN_STR_VALUE(" term "));"
    else:
      if (String-Stream? output)
        write-string-stream output term
      else:
        inline-c "fprintf(GIN_NIM_GET_STREAM(" output "),\"%s\", GIN_STR_VALUE(" term "));"

  if (Null? term) (print-primitive "null")
  elsif: (list? term)
    print-primitive "("
    each i term
      print-term i
      print-primitive " "
    print-primitive ")"
  elsif: (Cons? term)
    print-primitive "("
    print-term (first term)
    print-primitive " . . "
    print-term (second* term)
    print-primitive ")"
  elsif: (String? term) 
    print-primitive term
  elsif: (Binary? term) (print-primitive (Binary->String term))
  elsif: (Function? term) (print-primitive (Function->String term))
  elsif: (Char? term) (print-primitive (Char->String term))
  elsif: (Boolean? term) (print-primitive (Boolean->String term))
  elsif: (Fixnum? term) (print-primitive (Fixnum->String term))
  elsif: (Integer? term) (print-primitive (Fixnum->String term))
  elsif: (Flonum? term) (print-primitive (Flonum->String term))
;  elsif: (Stream? term) (print-primitive (Stream->String term))
;  elsif: (String-Stream? term) (print-primitive (String-Stream->String term))
  elsif: (Vector? term) (print-primitive (Vector->String term))
  elsif: (Dict? term) (print-primitive (Dict->String term))
;  elsif: (Class? term) (print-primitive (class-to-str term))
  elsif: (Symbol? term) (print-primitive (Symbol->String term))
  else: (print-primitive (Foreign->String term))

define print (residual: terms)
  if (and (> (length terms) 0) (Generic-Stream? (first terms)))
    each i (second* terms)
      print-term (first terms) i
  else:
    each i terms
      print-term i

define println (residual: terms)
  if (and (> (length terms) 0) (Generic-Stream? (first terms)))
    each i (second* terms)
      print-term (first terms) i
    print-term (first terms) newline_
  else:
    each i terms
      print-term i
    print-term newline_

; write-term, write and writeln are for human readable output
define write-term (residual: z)
  define output false
  define term false

  if (and (= (length z) 2) (Generic-Stream? (first z)))
    set output (first z)
    set term (second z)
  elsif: (= (length z) 1)
    set term (first z)
  else:
    println "Invalid number of terms to display."
    exit

  define write-primitive (term)
    if (false? output)
      inline-c "fprintf(stdout,\"%s\", GIN_STR_VALUE(" term "));"
    else:
      if (String-Stream? output)
        write-string-stream output term
        
      else:
        inline-c "fprintf(GIN_NIM_GET_STREAM(" output "),\"%s\", GIN_STR_VALUE(" term "));"

  if (Null? term) (write-primitive "null")
  elsif: (list? term)
    write-primitive "("
    each i term
      write-term i
      write-primitive " "
    write-primitive ")"
  elsif: (Cons? term)
    write-primitive "("
    write-term (first term)
    write-primitive " . . "
    write-term (second* term)
    write-primitive ")"
  elsif: (String? term) 
    write-primitive "\""
    write-primitive term
    write-primitive "\""
  elsif: (Binary? term) (write-primitive (Binary->String term))
  elsif: (Function? term) (write-primitive (Function->String term))
  elsif: (Char? term) (write-primitive (Char->String term))
  elsif: (Boolean? term) (write-primitive (Boolean->String term))
  elsif: (Fixnum? term) (write-primitive (Fixnum->String term))
  elsif: (Integer? term) (write-primitive (Fixnum->String term))
  elsif: (Flonum? term) (write-primitive (Flonum->String term))
;  elsif: (Stream? term) (write-primitive (Stream->String term))
;  elsif: (String-Stream? term) (write-primitive (String-Stream->String term))
  elsif: (Vector? term) (write-primitive (Vector->String term))
  elsif: (Dict? term) (write-primitive (Dict->String term))
;  elsif: (Class? term) (write-primitive (class-to-str term))
  elsif: (Symbol? term) (write-primitive (Symbol->String term))
  else: (write-primitive (Foreign->String term))

define write (residual: terms)
  if (and (> (length terms) 0) (Generic-Stream? (first terms)))
    each i (second* terms)
      write-term (first terms) i
  else:
    each i terms
      write-term i

define writeln (residual: terms)
  if (and (> (length terms) 0) (Generic-Stream? (first terms)))
    each i (second* terms)
      write-term (first terms) i
    write-term (first terms) newline_
  else:
    each i terms
      write-term i
    write-term newline_

define apply (fn args)
  inline-c "CALLNDYNAMIC(" fn ", next_seed, " result ", " args ");"
  inline-c "next_seed++;"

define command-line ()
  define i 0
  define r null
  inline-c i " = GIN_IM_FROM_INT(gin_argc);"
  while (> i 0)
    define str false
    -- i
    inline-c "GIN_NEW_STR8(" str ",gin_argv[GIN_IM_TO_INT(" i ")]);"
    set r (pair str r)
  r

define exit ()
  inline-c "exit(0);"

define trait (obj key)
  if (Null? (properties obj)) 
    false
  elsif: (false? (properties obj)) 
    false
  else:
    Dict::get (properties obj) key

define trait! (obj key value)
  Dict::set (properties obj) key value

; TODO: REWRITE THESE A BIT

; Given a list return true if the list represents a function definition.
; A function defintion has the form:
;   define name (arg-list) 
;     (body)
; So to determine if the list is a function we need to know if its
; first element is the symbol 'define or 'define! followed by a
; name, argument list, and a body. In other words it needs to
; be a list of 4 elements with the first element 'define or 'define!.
; We check if the first element and then check if there are 3 additional 
; elements for a total of 4 elements.
define <term> function-definition? (self)
  define number-of-terms-after-define 3
  if (<term>::definition? self)
    define terms (second* self)
    if (= (length terms) number-of-terms-after-define)
      true
    else:
      false
  else:
    false

define <term> method-definition? (self)
  define number-of-terms-after-define 4
  if (<term>::definition? self)
    define terms (second* self)
    if (= (length terms) number-of-terms-after-define)
      true
    else:
      false
  else:
    false

define <term> get-definition-name (self)
  ; TODO - it is bad practice to return two different types (String
  ; and Symbol in this case)
  if (<term>::method-definition? self)
    String::append (Symbol->String (second self)) "::" (Symbol->String (third self))
  else:
    second self

define <term> get-definition-body (self)
  if (<term>::method-definition? self)
    fifth self
  else:
    fourth self

define <term> get-definition-arguments (self)
  if (<term>::method-definition? self)
    fourth self
  elsif: (<term>::function-definition? self)
    third self
  else:
    false

define Term::head (v)
  if (Cons? (properties v))
    Term::head (properties v)
  else:
    v

define <term> parent (o)
  set o (Term::head o)
  if (or (Null? o) (false? o)) false
  else:
    set o (trait o 'parent)
    if (or (Null? o) (false? o)) false
    else:
      set o (Term::head o)
      if (or (Null? o) (false? o))  false
      else:
        o

define <term> get-parent-function (f)
  define get-f (v)
    if (or (Null? v) (false? v))
      false
    elsif: (or (<term>::function-definition? v) (<term>::method-definition? v))
      v
    else:
      get-f (<term>::parent v)
  get-f (<term>::parent f)

define <term> definition-symbol? (v)
  and (Symbol? v) (or (Symbol::eq? v 'define) (Symbol::eq? v 'define!))

define <term> each-loop? (v)
  and (list? v) (Symbol? (first v)) (Symbol::eq? (first v) 'each)

define <term> definition? (f)
  and (Cons? f) (<term>::definition-symbol? (first f))

define <term> immutable-definition? (f)
  and (Symbol? (first f)) (Symbol::eq? (first f) 'define!)

define <term> quoted-symbol? (v)
  and (Cons? v) (Symbol? (first v)) (Symbol::eq? (first v) 'quote)

; TODO - not sure if this documentation is correct
; Find parameters that are named as in (sender: obj)???
define find-named-parameter (plst a)
  if (Symbol? a)
    set a (Symbol->String a)

  if (Null? plst) 
    false
  elsif: (and (String? (first plst)) (String::eq? (first plst) (String::append a ":")))
    ; TODO: fails if xxx: is the last term in the list.
    pair (first plst) (second plst)
  else:
    find-named-parameter (second* plst) a

define Char->digit (v (b 10))
  require (Integer? b)
  require (Char? v)
  ensure (Number? result)
  define c
    if (< b 2)
      false
    elsif: (> b 36)
      false
    elsif: (>= (Char->Integer v) (Char->Integer a_))
      + (- (Char->Integer v) (Char->Integer a_)) 10
    elsif: (>= (Char->Integer v) (Char->Integer A_))
      + (- (Char->Integer v) (Char->Integer A_)) 10
    elsif: (>= (Char->Integer v) (Char->Integer 0_))
      - (Char->Integer v) (Char->Integer 0_)
    else: false
  if (not c) false
  elsif: (< c b) c
  else: false

define Char digit? (v b)
  require (Integer? b)
  require (Char? v)
  if (not (Char->digit v b)) false
  else: true

define eos-object? (obj)
  inline-c result "= GIN_IM_FROM_BOOL(" obj " == GIN_IM_FROM_CHAR8(EOF));"

define eos? (input)
  eos-object? (peek-char input)

define Char eol? (c)
  require (Char? c)
  if (Char::eq? c lf_) true
  elsif: (Char::eq? c cr_) true
  elsif: (Char::eq? c newline_) true  ; could be a \n 
  else: false

define new-string (a b)
  if (and (String? a) (String? b)) (String::append a b)
  elsif: (and (String? a) (Char? b)) (String::append a (String::string b))
  elsif: (and (Char? a) (String? b)) (String::append (String::string a) b)
  elsif: (and (Char? a) (Char? b)) (String::append (String::string a) (String::string b))
  else: false

; Return everything after the first character in a string.
define String rest (v)
  require (String? v)
  if (<= (String::length v) 1) ""
  else: (String::substring v 1 (String::length v))

define String Boolean? (v)
  require (String? v)
  if (or (String::eq? v "true") (String::eq? v "false")) true
  else: false

define String ellipses? (v)
  require (String? v)
  if (String::eq? v "..") true
  else: false

define String->Symbol (v)
  require (String? v)
  if (String::Symbol? v)
    Ginger::String->Symbol v
  else:
    false

define String->Character (v)
  define va (String::split v underscore_)
  if (= (length va) 2) 
    define name (first va)
    define name-len (String::length (first va))
    if (= (String::length (second va)) 0)
      if (= name-len 1)
        ; simple ascii conversion
        ; TODO: Certain ones shouldn't be valid:
        ; space, newline, tab, colon, etc.
        String::first name
      else:
        ; Special cases
        ; TODO: Replace with hash lookup for speed.
        if (String::eq? name "at")
          inline-c "GIN_NEW_CHAR8(" result ", '@')"
        elsif: (String::eq? name "backslash")
          inline-c "GIN_NEW_CHAR8(" result ", 92)"
        elsif: (String::eq? name "colon")
          inline-c "GIN_NEW_CHAR8(" result ", 58)"
        elsif: (String::eq? name "cr")
          inline-c "GIN_NEW_CHAR8(" result ", 13)"
        elsif: (String::eq? name "double-quote")
          inline-c "GIN_NEW_CHAR8(" result ", 34)"
        elsif: (String::eq? name "lbrace")
          inline-c "GIN_NEW_CHAR8(" result ", '{')"
        elsif: (String::eq? name "lbracket")
          inline-c "GIN_NEW_CHAR8(" result ", '[')"
        elsif: (String::eq? name "lf")
          inline-c "GIN_NEW_CHAR8(" result ", 10)"
        elsif: (String::eq? name "lparen")
          inline-c "GIN_NEW_CHAR8(" result ", '(')"
        elsif: (String::eq? name "newline")
          inline-c "GIN_NEW_CHAR8(" result ", 10)"
        elsif: (String::eq? name "null")
          inline-c "GIN_NEW_CHAR8(" result ", 0)"
        elsif: (String::eq? name "pipe")
          inline-c "GIN_NEW_CHAR8(" result ", '|')"
        elsif: (String::eq? name "rbrace")
          inline-c "GIN_NEW_CHAR8(" result ", '}')"
        elsif: (String::eq? name "rbracket")
          inline-c "GIN_NEW_CHAR8(" result ", ']')"
        elsif: (String::eq? name "rparen")
          inline-c "GIN_NEW_CHAR8(" result ", ')')"
        elsif: (String::eq? name "semi-colon")
          inline-c "GIN_NEW_CHAR8(" result ", 59)"
        elsif: (String::eq? name "single-quote")
          inline-c "GIN_NEW_CHAR8(" result ", 39)"
        elsif: (String::eq? name "slash")
          inline-c "GIN_NEW_CHAR8(" result ", '/')"
        elsif: (String::eq? name "space")
          inline-c "GIN_NEW_CHAR8(" result ", ' ')"
        elsif: (String::eq? name "tab")
          inline-c "GIN_NEW_CHAR8(" result ", 9)"
        elsif: (String::eq? name "tilde")
          inline-c "GIN_NEW_CHAR8(" result ", '~')"
        elsif: (String::eq? name "underscore")
          inline-c "GIN_NEW_CHAR8(" result ", '_')"
        else:
          false
    elsif: (String::eq? (second va) "u")
      ; TODO: Unicode not complete
      false
    else:
      false
  else: 
    false

define String Character? (v)
  require (String? v)
  if (not (String->Character v)) false
  else: true

define String Symbol? (v)
  require (String? v)

  define char-legal-symbol? (v)
    if (Char::alphabetic? v) true
    elsif: (Char::numeric? v) true
    elsif: (Char::eq? v +_) true
    elsif: (Char::eq? v -_) true
    elsif: (Char::eq? v *_) true
    elsif: (Char::eq? v /_) true
    elsif: (Char::eq? v %_) true
    elsif: (Char::eq? v $_) true
    elsif: (Char::eq? v @_) true
    elsif: (Char::eq? v !_) true
    elsif: (Char::eq? v <_) true
    elsif: (Char::eq? v >_) true
    elsif: (Char::eq? v =_) true
    elsif: (Char::eq? v ?_) true
    elsif: (Char::eq? v colon_) true
    ; elsif: (Char::eq? v ^_) true
    else: false

  define string-legal-symbol? (v)
    if (= (String::length v) 0) false
    elsif: (and (= (String::length v) 1) (char-legal-symbol? (String::first v))) true
    elsif: (char-legal-symbol? (String::first v)) (string-legal-symbol? (String::rest v))
    else: false

  define t false
  set sv-err false
  inline-c t "= gin_string_to_value(" v ");"
  inline-c "if (" t " == 0) { " sv-err " = GIN_TRUE;" t " = GIN_FALSE; }"
  if (not (String? t))
    false
  else:
    if (string-legal-symbol? v)
      if (Char::eq? (String::first v) colon_)
        false
      else:
        true
    else: false

define sv-err false
define String->Value (v)
  define t false
  set sv-err false
  inline-c t "= gin_string_to_value(" v ");"
  inline-c "if (" t " == 0) { " sv-err " = GIN_TRUE;" t " = GIN_FALSE; }"
  if (String? t)
    define tmp (Ginger::String->Symbol v)
    if (Char::eq? (String::last t) colon_)
      inline-c result "= GIN_IM_FROM_LABEL(GIN_IM_TO_SYM(" tmp "));"
    else:
      tmp
  else:
    t

define String Label? (v)
  require (String? v)
  ; TODO - when DBC works remove the first conditional
  if (String? v)
    if (Char::eq? (String::last v) colon_)
      define t false
      inline-c t "= gin_string_to_value(" v ");"
      inline-c "if (" t " == 0) { " t " = GIN_FALSE; }"
      if (String? t)
        true
      else:
        false
    else: 
      false
  else:
    false

define include-filename (terms)
  first (second* (first terms))

define open-include-file (filename)
  define found-include-file false
  define include-file-path ""
  if (file-exists? filename)
    set found-include-file true
    set include-file-path filename
  else:
    define inc-paths (String::split (getenv "GIN_INCLUDE_PATH" "") colon_)
    while (and (not found-include-file) (not (Null? inc-paths)))
      define path (String::append (first inc-paths) "/" filename)
      if (file-exists? path)
        set found-include-file true
        set include-file-path path
      set inc-paths (second* inc-paths)
  if (not found-include-file)
    println "No file found for include: " filename
    exit
  open-input-file include-file-path

define expand-includes (tree)
  ; TODO - make sure include in quoted list does not expand

  define include? (node)
    if (and (Cons? node) (Cons? (first node)) (Symbol? (first (first node))))
      Symbol::eq? (first (first node)) 'include
    else:
      false

  define expand-include (node)
    ; TODO - Test if '(include "hello") get's expanded
    println "Expanding " (include-filename node)
    define input (open-include-file (include-filename  node))
    define tmp (read input)
    expand-includes tmp

    define old-second* (second* node)
    first! node (first tmp) ; replace (include "file.gin") with expand tree
    define z (last* tmp)
    second*! z old-second*
    second*! node (second* tmp)
    
    close-input-stream input

  define includes (trait tree 'includes)

  each i includes
    define node (trait i 'parent)
    if (include? node)
      expand-include node

; TODO: deprecate this
define <term>::make (parent parse-indent line value)
  cons value (Dict::make 'parent parent 'paren-balance 0 'parse-indent parse-indent 'line line 'begin false) null

define <group>::make (line)
  ; TODO: make this a bcons
  ; <term>::make null 0 line false
  cons null (Dict::make 'parent null 'paren-balance 0 'parse-indent 0 'line line 'begin false) null

define Group? (a)
  ; TODO check bcons
  if (Cons? a)
    if (not (Null? (properties a)))
      true
    else:
      false
  else:
    false

define read (input (tree-head null))

  define includes null
  define line 1
  define column 0
  define cbq-indent 0

  define state-stack (Vector::make)

  define state-push (s)
    Vector::push state-stack s

  define state-top ()
    Vector::last state-stack

  define state-pop ()
    ;if (or (Null? state-stack) (Null? (second* state-stack)))
    ;  println "Error: Can't have empty state stack"
    ;  exit
    Vector::pop state-stack

  define begin-group? (t)
    if (true? (trait t 'begin))
      true
    else: false

  define paren-balanced ()
    define paren-balanced2 (t)
      require (not (false? t))
      if (begin-group? t)
        if (= (trait t 'paren-balance) 0) null
        else: t
      else:
        paren-balanced2 (Term::head (trait t 'parent))
    paren-balanced2 tree-current-head

  define paren-add ()
    define add-paren2 (t)
      require (not (false? t))
      if (begin-group? t)
        trait! t 'paren-balance (+ (trait t 'paren-balance) 1)
      else:
        add-paren2 (Term::head (trait t 'parent))
    add-paren2 tree-current-head

  define paren-remove ()
    define remove-paren2 (t)
      require (not (false? t))
      if (begin-group? t)
        trait! t 'paren-balance (- (trait t 'paren-balance) 1)
      else:
        remove-paren2 (Term::head (trait t 'parent))
    remove-paren2 tree-current-head
 
  if (Null? tree-head) (set tree-head (<group>::make 0))

  define tree-current-head tree-head
  define tree-current-cell tree-head
  define tree-current-cell-free true

  define tree-add (v line)
    ; If the current cell is empty use it, otherwise add a new one.
    if (tree-current-cell-free)
      set tree-current-cell-free false
      ; Use the value
      first! tree-current-cell v
    else:
      set v (cons v tree-current-cell null)
      second*! tree-current-cell v
      ; properties! v tree-current-cell
      set tree-current-cell v
    if (not (Cons? (properties tree-current-cell)))
      trait! tree-current-cell 'line line

    tree-current-cell

  define tree-push ()
    define g0 false
    if (tree-current-cell-free)
      set g0 tree-current-cell
    else:
      set g0 (cons null tree-current-cell null)
    define g1 (<group>::make line)
    first! g0 g1
    if (tree-current-cell-free)
      set tree-current-cell-free false
    else:
      second*! tree-current-cell g0
      properties! g0 tree-current-cell
      set tree-current-cell g0
    trait! g1 'parent g0

    set tree-current-head g1
    set tree-current-cell g1
    set tree-current-cell-free true

  define tree-pop ()
    if (not (Null? (trait tree-current-head 'parent)))
      set tree-current-cell (trait tree-current-head 'parent)
      set tree-current-head (Term::head tree-current-cell)
      set tree-current-cell-free false
    else:
      println "Could not find parent."
      exit

  define tree-unpop ()
    set tree-current-head (last tree-current-head)
    set tree-current-cell (last* tree-current-head)

  define tree-set-begin ()
    trait! tree-current-head 'begin true

  define tree-sibling-count ()
    - (length tree-current-head) 1

  if (String? input)
    set input (String::append input (String::string newline_))
    set input (open-input-string input)

  define c false
  define p false
  define buffer ""
  define buffer-begin 0
  define buffer-end 0
  define eos false
  define parse-indent -1
  define is-quote 0
  define first-term-on-line true
  ; 0 = no quote, 1 = buffer is from a quote, 2 = buffer is from an empty quote
  ; -1 = buffer is a symbol quote, -2 = buffer is from an empty symbol quote

  state-push 'begin
  tree-set-begin

  while (not eos)
    if (eos? input)
      set eos true ; terminate next time through the loop
      set c space_ ; set c to space.

      ; if its eos we need to check for paren balence because its usualy done by
      ; indentation checking but there will be no more lines to check the last line
      if (not (Null? (paren-balanced)))
        println "Error in code block starting on line " (trait tree-current-head 'line) ": unbalanced parenthesis.1"
        exit
    else:
      set c (get-char input) ; get the next character

      ; windows consideration for dual eol's
      if (and (Char::eq? c cr_) (Char::eq? (peek-char input) lf_))
        set c (get-char input)

      if (not (Char::whitespace? c))
        if (= parse-indent -1)
          set parse-indent column

    ; As we read a character we might be in one of several states:
    ; 1. Colon Quoting
    ; 2. Double Quoting
    ; 3. Reading Commands

    define current-state (state-top)
    ;println "C=" c
    ;println "buffer=" buffer
    ;println tree-head
    ;println "-------------------------------------------------------------------"

    if (Symbol::eq? current-state 'colon-quote)
      ; if we are allready in colon quote state then it can never be the first term on the line
      set first-term-on-line false
      if (or (Char::eq? c lparen_) (Char::eq? c rparen_) (Char::eol? c) (eq? eos true))
        if (and (Char::eq? p backslash_) (not (Char::eol? c)))
          ; removed the \\ created becuase of the one \ and add the current char ( or )
          set buffer (String::substring buffer 0 (- (String::length buffer) 2))
          set buffer (new-string buffer c)
        else:
          ; if p was not a backslash, we have three options:
          if (Char::eq? c lparen_)

            ; Option 1 - We encounter a left parenthesis
            ; The beginning of a command temporarily suspends this colon quote
            ; Add what we have so far to the concatenation operator

            ; tree-add (cons buffer null null) line
            tree-add buffer line

            ; Clear the buffer
            set buffer ""

            paren-add

            ; Add a new group for the command
            tree-push
            trait! tree-current-head 'parse-indent parse-indent

            ; And then add commands..
            state-push 'command

          elsif: (or (Char::eq? c rparen_) (Char::eol? c) (eq? eos true))

            ; Option 2 - we encounter a right parenthesis, eol, or eos
            ; The end of a colon quote so we need to check for
            ; colon block quote and if this is one then handle it
            ; otherwise we need to wrap everything up.

            define exit-colon-quote false
            if (not (Char::eol? c))
              ; if its a right parenthis or eos
              set exit-colon-quote true
              ; if its a right parenthis make sure we ajust the tree to account for it
              if (Char::eq? c rparen_)
                paren-remove
                ; if there is to many right parens we imeadetly know we should error
                if (not (Null? (paren-balanced)))
                  if (< (trait (paren-balanced) 'paren-balance) 0)
                    println "Error in code block starting on line " (trait tree-current-head 'line) ": unbalanced parenthesis.2"
                    exit
            else:
              ; Handle the EOL

              define next-indent-count 0
              define look-ahead-count 0
              define undo-block-quote-check false
              ; cbq-indent is 0 if it's the line that starts the colon quote.
              ; Otherwise it is equal to the amount of indentation for the 
              ; line that immediate succeeds the colon quote initiation.
              if (= cbq-indent 0)
                ; count all leading spaces
                define valid-line false
                while (not (valid-line))
                  while (Char::eq? (peek-char input) space_)
                    get-char input
                    ++ look-ahead-count
                    ++ next-indent-count
                  ; TODO - fix for crlf
                  if (Char::eq? (peek-char input) newline_)
                    set valid-line false
                    set next-indent-count 0
                    ; eat newline so we can start counting the space for the next line
                    get-char input                    
                    ++ look-ahead-count
                  else:
                    set valid-line true
                ; if its indented then save the indent
                if (> next-indent-count (trait tree-current-head 'parse-indent))
                  set cbq-indent next-indent-count
                  set look-ahead-count 0
                  ; if there is something in the buffer then we need to
                  ; add an eol to it
                  if (not (= (String::length buffer) 0))
                    set buffer (new-string buffer newline_)
                else:
                  ; since we did not find indentation we undo the last few lines
                  ; and wrap up colon-quote
;                if (not (String::eq? buffer ""))
                  ; Don't do this in a block quote..
                  ;set undo-block-quote-check true
                  set exit-colon-quote true
              ; if we have been working with a colon-block-quote
              else:
                ; count all leading spaces up to the first colon-block-quote-indent
                ;while (and (Char::eq? (peek-char input) space_) (< next-indent-count cbq-indent))
                ;  get-char input
                ;  ++ next-indent-count
                
                define valid-line false
                while (not (valid-line))
                  while (Char::eq? (peek-char input) space_)
                    get-char input
                    ++ look-ahead-count
                    ++ next-indent-count
                  
                  ; TODO - fix for crlf
                  if (Char::eq? (peek-char input) newline_)
                    ; eat newline, so we can start counting the space for the next line
                    get-char input
                    
                    if (Char::eq? (peek-char input) space_)
                      ; count spaces
                      define num-spaces 0
                      while (Char::eq? (peek-char input) space_)
                        get-char input
                        ++ num-spaces

                      ; put back spaces
                      define i 0
                      while (< i num-spaces)
                        unget-char input space_
                        ++ i
                      
                      if (= num-spaces cbq-indent)
                        ; add a newline
                        set buffer (new-string buffer newline_)

                    set valid-line false
                    set next-indent-count 0
                    ++ look-ahead-count
                  else:
                    set valid-line true
                if (> next-indent-count cbq-indent)
                  set next-indent-count cbq-indent


                ; if its still >= the first colon-block-quote-indent then we add a new line
                ; and continue
                if (>= next-indent-count cbq-indent)
                  set look-ahead-count 0
                  if (not (= (String::length buffer) 0))
                    set buffer (new-string buffer newline_)
                ; if its not the we reset cbq-indent and un what we did in the last few lines
                ; and wrap up colon-quote
                else:
                  set cbq-indent 0
                  ; set undo-block-quote-check true
                  set exit-colon-quote true

              ; undo the check for colon-block-quoteing
              if (> look-ahead-count 0) ; (undo-block-quote-check)
                while (> next-indent-count 0)
                  unget-char input space_
                  -- next-indent-count

            ; wraps up colon-quoteing
            if (exit-colon-quote)
              ; add buffer to tree and clear it
              ; tree-add (cons buffer null null) line column
              tree-add buffer line
              set buffer ""
              
              tree-pop ; pop the String::append              
              state-pop ; pop the colon quote state
              
              tree-pop ; pop the enclosing command
              state-pop ; pop the command state

      else:

        ; Option 3 - Anything else gets added to the buffer
        ; check to see if its a backslash since String::append
        ; uses \ for escape chars we just assume all \ are not
        ; escape chars and conver them to \\.

        if (Char::eq? c backslash_)
          define dbs (new-string c c)
          set buffer (new-string buffer dbs)
        else:
          set buffer (new-string buffer c)


    elsif: (Symbol::eq? current-state 'single-quote)

      if (or (Char::whitespace? c) (Char::eq? c rparen_))
        ; Push the character back so it can be handled properly next time..
        unget-char input c
        ; Set c to the more innocuos space so the eol stuff at the end of the loop
        ; doesnt trip us up
        set c space_
        state-pop
        ; Set is-quote to one if the buffer has something in it.
        set is-quote -1
        if (= (String::length buffer) 0)
          ; If the buffer is empty set is-quote to 2
          set is-quote -2
          set buffer "null"
      else:
        set buffer (new-string buffer c)

    elsif: (Symbol::eq? current-state 'double-quote)

      if (Char::eq? p backslash_)
        
        define escape-char (c)
          require (Char? c)
          if (Char::eq? c n_) 
            String::string newline_
          elsif: (Char::eq? c r_) 
            String::string cr_
          elsif: (Char::eq? c double-quote_) 
            String::string double-quote_
          else: c

        set buffer (new-string buffer (escape-char c))
        ; Set c to something other than \ so that p doesn't become \ and we escape the next time.
        set c space_

      else:
        if (Char::eq? c double-quote_)
          ; An ending double quote ends a double quote.
          state-pop
          set is-quote 1
          if (= (String::length buffer) 0)
            set is-quote 2
            set buffer "null"
        elsif: (Char::eq? c backslash_)
          ; eat it.
          noop
        else:
          set buffer (new-string buffer c)

    elsif: (Symbol::eq? current-state 'comment)
      if (Char::eol? c)
        state-pop ; pop comment state
        if (and (not (Symbol::eq? (state-top) 'begin)) (not first-term-on-line))
          ; this is inline comment so need to unget c and set it to a space
          ; so the defult code for the line can wrap things up
          unget-char input c
          set c space_

    elsif: (or (Symbol::eq? current-state 'begin) (Symbol::eq? current-state 'command))

      if (Char::eq? c semi-colon_)
        state-push 'comment

        ; This next bit of code simply skips through the commments a little faster
        ; by avoiding another pass through the main loop
        define z true
        while (z)
          set z (get-char input)
          if (or (Char::eol? z) (eof-object? z))
            unget-char input z
            set z false
          else:
            set z true

      elsif: (Char::eq? c double-quote_)
        state-push 'double-quote

      elsif: (Char::eq? c single-quote_)
        state-push 'single-quote

      elsif: (or (Char::eq? c lparen_) (Char::eq? c rparen_) (Char::whitespace? c))

        if (Char::eq? c lparen_)
          if (and (String::eq? buffer ":") (= is-quote 0))
            println "Error on line " line ", column " column ": illegal colon-quote."
            exit
          else:
            set buffer "("

        if (Char::eq? c rparen_)
          paren-remove
          if (not (Null? (paren-balanced)))
            if (< (trait (paren-balanced) 'paren-balance) 0)
              println "Error in code block starting on line " (trait tree-current-head 'line) ": unbalanced parenthesis.3"
              exit

        if (and (Char::whitespace? c) (not (Char::eol? c)) (= (String::length buffer) 0))
          ; ignore spaces that precede a command
          noop
        else:
          if (and (String::eq? buffer ":") (= is-quote 0))
            ; defult colon-quote (:_something) or :_something or (:)
            ; if whitespace follows a : then do not error but ...
            if (or (Char::eq? space_ c) (Char::eol? c) (Char::eq? rparen_ c))
              ; allthough (:) is useless it should be a valid placeholder
              unget-char input c ; put the char back
              if (Char::eq? c rparen_)
                ; conter act the paren-remove above because we are going to process it twice
                paren-add
                unget-char input space_
              else:
                set buffer ":String::append" ; override the buffer with the defult command
                set p d_ ; update p with what it should be
              set c space_ ; reset c to a space

          elsif: (= (String::length buffer) 0)
            ; There is nothing in the buffer
            if (Char::eol? c)
              ; Nothing in the buffer and it is an EOL
              if (and (not (Symbol::eq? (state-top) 'begin)) (not first-term-on-line))
              ; if (not (Symbol::eq? (state-top) 'begin))
                ; EOL - we need to undo this if we find an ..
                state-pop
                tree-pop
            if (Char::eq? c rparen_)
              if (= (tree-sibling-count) 0)
                trait! tree-current-head 'parse-indent parse-indent
              state-pop
              tree-pop
          else:
            ; TODO - this if statement is not necc?
            ; if (or (Symbol::eq? (state-top) 'begin) (Symbol::eq? (state-top) 'command))
            if (true? first-term-on-line)
              set first-term-on-line false
              if (> (String::length buffer) 0)
                if (< (trait tree-current-head 'parse-indent) parse-indent)

                  ; CASE 1 - The current indentation is more than the previous
                  ; indentation.  This indicates a code block associated with the
                  ; previous line.

                  ; println "CASE 1  - " (trait tree-current-head 'parse-indent) " - " parse-indent

                  if (not (Null? (paren-balanced)))
                    println "Error in code block starting on line " (trait tree-current-head 'line) ": unbalanced parenthesis.4"
                    exit

                  if (String::ellipses? buffer)
                    ; Over indented ellipses don't make any sense!
                    println "Error on line " line ", column " column ": illegal ellipses indentation."
                    exit

                  if (String::Label? buffer)
                    ; Over indented labels don't make any sense!
                    println "Error on line " line ", column " column ": illegal label indentation. (" (trait 'parse-indent tree-current-head) ", " parse-indent ")"
                    exit

                  ; We need to "continue" the last line with a code block
                  ; set tree-current (last (second* tree-current))
                  ; tree-continue
                  tree-unpop

                  ; We need to account for this by adding an extra state..
                  state-push 'command

                  ; Add a new group
                  tree-push
                  ;println ":debug ADDING " buffer " as GROUP"
                  trait! tree-current-head 'parse-indent parse-indent
                  state-push 'begin

                  ; Add a new begin
                  tree-set-begin

                  ; Add a group for this command
                  tree-push
                  trait! tree-current-head 'parse-indent parse-indent
                  state-push 'command

                elsif: (> (trait tree-current-head 'parse-indent) parse-indent)

                  ; CASE 2 - The current indentation is less than the previous
                  ; indentation.  We need to "close" some code blocks and
                  ; begin adding to a different block.

                  ; println "Case 2 - " (trait tree-current-head 'parse-indent) " - " parse-indent

                  ; Keep popping the tree until we get to an indent <= the current
                  while (< parse-indent (trait tree-current-head 'parse-indent))
                    if (not (Null? (paren-balanced)))
                      println "Error in code block starting on line " (trait (paren-balanced) 'line) ": unbalanced parenthesis.5"
                      exit
                    tree-pop
                    state-pop

                  tree-pop
                  state-pop

                  ; The indent should now be equal
                  if (not (= parse-indent (trait tree-current-head 'parse-indent)))
                    println "Error on line " line ", column " column ": illegal indentation."
                    println "[ " parse-indent ", " (trait tree-current-head 'parse-indent) "]"
                    exit

                  ; And we should be at a State.Begin..

                  if (or (String::ellipses? buffer) (String::Label? buffer))
                    tree-unpop
                    state-push 'command
                  else:
                  ; Add a group for this command
                    tree-push
                    trait! tree-current-head 'parse-indent parse-indent
                    state-push 'command

                else:
                  ; CASE 3 - Same indentation level

                  ; println "CASE 3 - buffer:  '" buffer "'"

                  if (or (String::ellipses? buffer) (String::Label? buffer))
                    ; undo what was done at the last line ending..
                    tree-unpop
                    state-push 'command
                  else:
                    if (not (Null? (paren-balanced)))
                      println "Error in code block starting on line " (trait 'line tree-current-head) ": unbalanced parenthesis.6"
                      exit
                    ; Add a group for this command
                    tree-push
                    trait! tree-current-head 'parse-indent parse-indent
                    state-push 'command

            if (= (tree-sibling-count) 0)
              trait! tree-current-head 'parse-indent parse-indent

            if (> is-quote 0)
              ; String
              ;println "----1"
              if (= is-quote 2)
                set buffer ""
              ; tree-add (cons buffer null null) line column
              tree-add buffer line
              set is-quote 0

            elsif: (< is-quote 0)
              ;println "----2"
              ;println ":debug READ QS " buffer
              ; TODO - Add a surrounding (quote ###) in a similar
              ; fashion to adding a colon command.

              ; Quoted symbol
              if (= is-quote -2)
                set buffer ""
              
              ; Add a new group for the command
              tree-push                                           
              trait! tree-current-head 'parse-indent parse-indent 
              
              ; tree-add (cons (String->Symbol "quote") null null) line column
              ; tree-add (cons (String->Symbol buffer) null null) line column
              tree-add (Ginger::String->Symbol "quote") line
              tree-add (Ginger::String->Symbol buffer) line
              
              tree-pop

              set is-quote 0

              ;tree-add (<value>::make 'symbol (Ginger::String->Symbol (String::rest buffer)) line column)
              ;tree-push
              ;trait! tree-current-head 'parse-indent parse-indent
              ;tree-add (<value>::make 'quoted-symbol (String->Symbol "quote") line column)
              ; 
              ;state-push 'single-quote
              ;if (Char::eol? c)
              ;  ; reuse eol for colon-quote
              ;  unget-char input c
              ;  set c space_
              ;else:
              ;  ; remove spaces between command and string
              ;  while (Char::eq? space_ (peek-char input))
              ;    get-char input
              ;set buffer ""

            elsif: (Char::eq? (String::nth buffer 0) colon_)
              ;println "COLON QUOTE"
              ; TODO: check for illegal symbols
              ; (:something ... ) or :something
              ; We have already added a group for the line and then a group for the
              ; begin paren. which is right...

              ; tree-add (<value>::make 'symbol (String->Symbol (String::rest buffer)) line column)
              tree-add (Ginger::String->Symbol (String::rest buffer)) line
              tree-push
              trait! tree-current-head 'parse-indent parse-indent
              ; tree-add (<value>::make 'symbol (String->Symbol "String::append") line column)
              tree-add (Ginger::String->Symbol "String::append") line
              state-push 'colon-quote
              if (Char::eol? c)
                ; reuse eol for colon-quote
                unget-char input c
                set c space_
              else:
                ; remove spaces between command and string
                while (Char::eq? space_ (peek-char input))
                  get-char input
              set buffer ""

            elsif: (String::ellipses? buffer)
              ;println "ELLIPSES"
              ; Ellipses
              if (= (trait tree-current-head 'line) 0)
                ; Files that begin with ellipses don't make any sense!
                println "Error on line " line ", " column ": illegal ellipses."
                exit

            elsif: (Char::eq? c lparen_)
              ;println "PAREN ADD"
              paren-add

              tree-push
              trait! tree-current-head 'parse-indent parse-indent
              state-push 'command

            else:
              ;println "STRING->VALUE " buffer
              define v (String->Value buffer)
              if (sv-err)
                ; Anything else is an error
                println "Error on line " line ", column: " column "invalid symbol '" buffer "'."
                exit
              else:
                define z (tree-add v line)
                if (Symbol? v)
                  if (Symbol::eq? v 'include)
                    set includes (pair z includes)

            if (Char::eol? c)
              if (not (Symbol::eq? (state-top) 'begin))
                state-pop
                tree-pop

            if (Char::eq? c rparen_)
              state-pop
              tree-pop

            set buffer ""
      else:
        set buffer (new-string buffer c)

    if (not (eos-object? input))
      if (Char::eol? c)
        ++ line
        set column 0
        set parse-indent -1
        set first-term-on-line true
      else:
        ++ column

    set p c

  trait! tree-head 'includes includes
  tree-head
